<!DOCTYPE html>
<html>
<!-- css framework documentation -->
<!-- https://purecss.io/grids/ -->

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writer</title>

  <link rel="stylesheet" href="./css/icons/style.css" />
  <link rel="stylesheet" href="./css/page.css" />
  <link rel="stylesheet" href="./css/colors-light.css" />

  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“‹</text></svg>" />
</head>

<style></style>

<body>
  <div id="main-menu">
    <a class="menu-button">
      <div class="lsf symbol">menu</div>
    </a>
    <a id="book-button" class="menu-button">
      <div class="lsf symbol">book</div>
    </a>
    <a id="edit-button" class="menu-button active">
      <div class="lsf symbol">edit</div>
    </a>
    <a id="convert-button" class="menu-button">
      <div class="lsf symbol">file</div>
    </a>
    <a id="clear-button" class="menu-button">
      <div class="lsf symbol">delete</div>
    </a>

    <div class="menu-separator"></div>

    <a id="bold-button" class="menu-button">
      <div class="lsf symbol">bold</div>
    </a>
    <a id="italic-button" class="menu-button">
      <div class="lsf symbol">italic</div>
    </a>
    <!-- NEW: List buttons -->
    <a id="ul-button" class="menu-button">
      <div class="lsf symbol">list</div>
    </a>
    <a id="ol-button" class="menu-button">
      <div class="lsf symbol">list</div>
    </a>
    <a id="unsaved-button" class="menu-button">
      <div class="lsf symbol">etc</div>
    </a>
  </div>

  <div id="dialog" class="">
    <div id="dialog-button-container">
      <a id="dialog-close-button" class="dialog-button">
        <div class="lsf symbol">close</div>
      </a>
      <a id="dialog-save-button" class="dialog-button">
        <div class="lsf symbol">check</div>
      </a>
    </div>
    <textarea name="content-text" id="content-text" cols="30" rows="10"></textarea>
  </div>

  <div id="page">
    <div id="container" contenteditable="true">
      <h1>Main title.</h1>
      <p>First paragraph which is awesome.</p>
      <h2>my title.</h2>
      <p>First paragraph which is awesome.</p>
      <p>Second paragraph which is amazing.</p>
      <p>Third paragraph which is great.</p>
      <p>One a paragraph <strong>bold</strong> which is awesome.</p>
      <p>Two b paragraph <strong>bold</strong> which is awesome.</p>
      <p>Three c paragraph <strong>bold</strong> which is awesome.</p>
      <h3>Footer title.</h3>
      <p>Third paragraph, <strong>bold</strong> and is even more awesome.</p>
      <p>4th paragraph, <em>italic</em> that is even more awesome.</p>
    </div>
  </div>

  <script>
    function $(selector, element = document) {
      return element.querySelector(selector);
    }

    function $$(selectors, element = document) {
      return Array.from(element.querySelectorAll(selectors.join(",")));
    }

    const dialog = $("#dialog");
    const dialogCloseButton = $("#dialog-close-button");
    const dialogSaveButton = $("#dialog-save-button");
    const boldButton = $("#bold-button");
    const italicButton = $("#italic-button");
    // NEW: List buttons
    const ulButton = $("#ul-button");
    const olButton = $("#ol-button");
    const editor = $("#container");
    const page = $("#page");
    const unsaved = $("#unsaved-button");

    const textNodeType = 3;
    const elementWhitelistBlockElements = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'LI'];
    const elementWhitelistBlockElementsInSelection = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI'];
    const elementWhitelistInlineElements = ['B', 'A', 'STRONG', 'I', 'EM'];
    const flags = {
      isPasting: false,
    };

    // HELPERS >>>>>>>>>>>>>>>>>>
    const helper = {
      ini() {
        this.saveDebounce = this.saveDebounce();
        this.elementsCleanupDebounce = this.elementsCleanupDebounce();
      },
      debounce: function (fn, delay) {
        var timer = null;
        return function () {
          var context = this,
            args = arguments;
          clearTimeout(timer);
          timer = setTimeout(function () {
            fn.apply(context, args);
          }, delay);
        };
      },
      saveDebounce: function () {
        return this.debounce(() => {
          localStorage.setItem("book", convertToText(Array.from(editor.children)));
          unsaved.style.display = "none";
        }, 1000)
      },
      // needed for removing empty inline elements after modification of the editor
      // unfortunately cannot be done on a mutation observer because in firefox does not seem to work properly
      // at least the empty b is not created, and we can also not observe a text node being removed from the b element (?)
      elementsCleanupDebounce: function (containerDom) {
        return this.debounce((containerDom) => {
          if (flags.isPasting) {
            return;
          }
          inlineElements = $$(elementWhitelistInlineElements, containerDom);

          inlineElements.forEach((inlineElement) => {
            if (!inlineElement.textContent && inlineElement.parentNode) {
              const parentNode = inlineElement.parentNode;
              inlineElement.remove();
              if (!parentNode.firstChild) {
                parentNode.innerHTML = "<br/>";
              }
            }
          });

          blockElements = $$(elementWhitelistBlockElements, containerDom);

          blockElements.forEach((blockElement) => {
            if (!blockElement.textContent && !blockElement.firstChild) {
              blockElement.remove();
            }
          });
        }, 500)
      },
      encodeHTMLEntities(rawStr) {
        return rawStr.replace(/[\u00A0-\u9999<>\&]/g, (i) => `&#${i.charCodeAt(0)};`);
      },
    }

    helper.ini();

    // VIEW METHODS <<<<<<<<<<<<<<<<<<<<<
    function toggleDialog() {
      dialog.classList.toggle("active");
    }

    // STORAGE METHODS <<<<<<<<<<<<<<<<<<<<<
    function loadDataOnPageLoad() {
      const book = localStorage.getItem("book");
      if (!book) {
        return;
      }
      loadFromText(book, editor);
    }
    // TODO turn this back on after testing
    loadDataOnPageLoad();

    // ENCODER DECODER <<<<<<<<<<<<<<<<<<<<<

    // EXTENDED loadFromText: now handles lists!

    function isValidHttpUrl(text) {
      if (!text.match(/^https?:\/\/.+/)) {
        return false;
      }

      try {
        new URL(text);
      } catch (_) {
        return false;
      }

      return true;
    }

    function convertTextToHTML(text, insideList = false) {
      // first if the pasted text is a url, we return it as a link
      if (isValidHttpUrl(text)) {
        return `<a href="${text}" target="_blank">${text}</a>`;
      }
      const blocks = text.split("\n\n");
      const blockType = {
        "#": "H1",
        "##": "H2",
        "###": "H3",
        "####": "H4",
        "#####": "H5",
        "######": "H6",
      };
      const blockElements = blocks.map((block) => {
        const lines = block.split("\n");
        // Check if this block is a list block (e.g. lines starting with "- " or "1. ")
        if (/^(\-|\*|\+|\d+\.)\s+/.test(lines[0])) {
          const isOrdered = /^\d+\./.test(lines[0]);
          const listTag = isOrdered ? "OL" : "UL";
          const listItems = lines.map(line => {
            const match = line.match(/^(\-|\*|\+|\d+\.)\s+(.*)$/);
            if (match) {
              return `<li>${convertTextToHTML(match[2], true)}</li>`;
            }
            return `<li>${convertTextToHTML(line, true)}</li>`;
          }).join("\n");
          return `<${listTag}>${listItems}</${listTag}>`;
        } else {
          let blockTypeKey = lines[0].match(/#+/);
          let blockTypeValue = blockType[blockTypeKey];
          if (!blockTypeValue) {
            blockTypeValue = "P";
          } else {
            lines[0] = lines[0].replace(/#+/, "").trim();
          }
          const htmlLines = lines.map((line) => {
            return parseInlineMarkdown(line);
          });
          const blockContent = htmlLines.join("<br>");

          if (insideList && blockTypeValue === "P") {
            return blockContent; // If inside a list, return just the content without wrapping in a <p>
          }
          return `<${blockTypeValue}>${blockContent}</${blockTypeValue}>`;
        }
      });

      return blockElements.join("\n");
    }

    function loadFromText(text, container) {
      container.innerHTML = convertTextToHTML(text);
    }

    function parseInlineMarkdown(text) {
      let html = text;

      // Parse inline code blocks: `code`
      html = html.replace(/`([^`]+)`/g, (match, p1) => {
        return `<code>${helper.encodeHTMLEntities(p1)}</code>`;
      });

      // Parse images: ![alt text](imageURL)
      //    The alt text can be optional (weâ€™ll match even an empty alt: ![](imageURL)).
      //    For example: ![A cat](https://example.com/cat.jpg)
      html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, src) => {
        return `<img src="${src}" alt="${altText}" />`;
      });

      // Parse links: [link text](http://example.com)
      html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, textContent, href) => {
        return `<a href="${href}" target="_blank">${helper.encodeHTMLEntities(textContent)}</a>`;
      });


      // Parse italic text: *italic*
      // Only match if there's no space after the opening `*` and no space before the closing `*`.
      html = html.replace(/(?<!\*)\*(?!\s)([^*]+?)(?<!\s)\*(?!\*)/g, (match, p1) => {
        return `<em>${p1}</em>`;
      });
      // Parse bold text: **bold**
      // Only match if there's no space after the opening `**` and no space before the closing `**`.
      //
      // Explanation of the RegExp:
      //   \*\*(?!\s)      => Match `**` that is NOT followed by a space
      //   ([^*]+?)        => Capture one or more non-asterisk characters (lazy)
      //   (?<!\s)\*\*     => Match `**` that is NOT preceded by a space (using a negative lookbehind if supported)
      //
      // For broad compatibility, we can do a slightly simpler pattern without the negative lookbehind,
      // but the pattern shown here demonstrates the intent. If negative lookbehind isn't supported in your environment,
      // consider alternative approaches or check browser compatibility.
      html = html.replace(/(?<!\*)\*\*(?!\s)([^*]+?)(?<!\s)\*\*(?!\*)/g, (match, p1) => {
        return `<strong>${p1}</strong>`;
      });

      // see explanation below
      html = html.replace(/\*\*\*(?!\s)([^*]+?)(?<!\s)\*\*\*/g, (match, p1) => {
        return `<em><strong>${p1}</strong></em>`;
      });

      // Parse italic with _: _italic_
      //    Same logic, but with underscores.
      html = html.replace(/(?<!_)_(?!\s)([^_]+?)(?<!\s)_(?!_)/g, (match, p1) => {
        return `<em>${p1}</em>`;
      });

      // Parse bold with __: __bold__
      //    Same logic, but with underscores.
      html = html.replace(/(?<!_)__(?!\s)([^_]+?)(?<!\s)__(?!_)/g, (match, p1) => {
        return `<strong>${p1}</strong>`;
      });

      // see explanation below
      html = html.replace(/___(?!\s)([^_]+?)(?<!\s)___/g, (match, p1) => {
        return `<em><strong>${p1}</strong></em>`;
      });

      return html;
    }

    // PASTE handler
    function convertToText(nodes, insideList = false) {

      let joiner = "\n\n";
      if (insideList) {
        joiner = ""
      }
      let textParts = nodes
        .map((block) => {
          // NEW: Handle UL lists
          // if statement when the block is an textnode
          if (block.nodeType === textNodeType) {
            const textContent = block.textContent.trim();
            return textContent;
          }
          if (block.tagName === "UL") {
            return Array.from(block.children)
              .map(li => `- ${convertToText(Array.from(li.childNodes), true)}`)
              .join("\n");
          }
          // NEW: Handle OL lists
          else if (block.tagName === "OL") {
            return Array.from(block.children)
              .map((li, index) => `${index + 1}. ${convertToText(Array.from(li.childNodes), true)}`)
              .join("\n");
          } else {
            if (block.tagName.startsWith("H")) {
              const prefix = "#".repeat(parseInt(block.tagName[1])) + " ";
              return prefix + convertInlineToText(Array.from(block.childNodes));
            }
            // this is the case where we only have a normal text node if we are inside a list
            // or other inline nodes
            if (insideList) {
              return convertInlineToText([block]);
            }
            // here we have a p element, so we dont have any prefix
            // we just loop over it's children and treat them as inline elements
            return convertInlineToText(Array.from(block.childNodes));
          }
        });

      textParts = textParts.filter((part) => {
        return part?.length > 0;
      });
      const text = textParts.join(joiner);
      return text;
    }

    function convertInlineToText(inlineElements) {
      const text = inlineElements
        .map((ie) => {
          let prefix = "";
          let postfix = "";
          if (ie.tagName == 'B' || ie.tagName == 'STRONG') {
            prefix = "**";
            postfix = "**";
            return prefix + convertInlineToText(Array.from(ie.childNodes)) + postfix;
          }
          if (ie.tagName == 'I' || ie.tagName == 'EM') {
            prefix = "*";
            postfix = "*";
            return prefix + convertInlineToText(Array.from(ie.childNodes)) + postfix;
          }
          if (ie.tagName == 'A') {
            return `[${ie.textContent.replace(/\n/g, '')}](${ie.href})`;
          }
          return ie.textContent.replace(/\n/g, '');
        })
        .join("");
      return text;
    }

    function convertTextAndDisplay() {
      $("#content-text").value = convertToText(Array.from(editor.children));
    }

    function isEmpty(editor) {
      if (editor.children.length === 1) {
        const p = editor.children[0];
        if (editor.children[0].tagName !== "P") {
          return true;
        }
      }
      if (!editor.children.length) {
        return true;
      }
      return false;
    }

    function clearContainer(container) {
      // container.innerHTML = `<p><br/></p>`;
      loadFromText(`
# Main title.

First paragraph which is awesome.

## my title.

One two three.

Four five six.

First paragraph which is awesome.

Second paragraph which is amazing.

Third paragraph which is great.

One a paragraph **bold** which is awesome.

Two b paragraph **bold** which is awesome.

Three c paragraph **bold** which is awesome.

- List item **one** ends here.
- List item **two** ends here.
- List item **three** ends here.
- List item **four** ends here.

### Footer title.

Third paragraph, **bold** and is even more awesome.

4th paragraph, *italic* that is even more awesome.
        `.trim(), editor);

      helper.saveDebounce();
    }

    function putCursorAtFirstElement(rootElement, tagName) {
      const firstElement = rootElement.querySelector(tagName);
      const sel = document.getSelection() || window.getSelection();
      const rangeOnFirstElement = new Range();
      rangeOnFirstElement.selectNode(firstElement);
      rangeOnFirstElement.collapse(false);
      sel.removeAllRanges();
      sel.addRange(rangeOnFirstElement);
      return rangeOnFirstElement
    }

    function carretToTextNodeEnd(sel, textNode) {
      let rangeOnLastElement = new Range();
      rangeOnLastElement.setStart(textNode, 0);
      rangeOnLastElement.setEnd(textNode, textNode.textContent.length);
      rangeOnLastElement.collapse(false);
      sel.removeAllRanges();
      sel.addRange(rangeOnLastElement);
    }

    function wrapSelectionWithInlineElement(tagName) {
      if (editor.lastSelection) {
        range = editor.lastSelection;
        const firstLineWrapper = document.createElement(tagName);
        const lastLineWrapper = document.createElement(tagName);

        const elements = getAllBlockElementsInSelection(editor, range, []);
        const isMultiLineSelection = elements.length > 1;

        const firstBlockNode = elements.shift();
        const lastBlockNode = elements.pop() || firstBlockNode;

        let startRange = range.cloneRange();
        const endRange = range.cloneRange();

        // first line
        if (isMultiLineSelection) {
          startRange.setEndAfter(firstBlockNode.lastChild);
        } else {
          // first for complete block selection, where it would not select the content
          // of the node, but the complete node itself
          const contentCopy = startRange.cloneContents();
          if (contentCopy.firstChild.tagName === firstBlockNode.tagName) {
            startRange.setStartBefore(firstBlockNode.firstChild);
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
        }

        const startContent = startRange.extractContents();

        if (!!startContent.textContent) {
          // firstChild is the <p>, firstChild.firstChild is the content within
          while (startContent.firstChild) {
            firstLineWrapper.append(startContent.firstChild);
          }
        }

        startRange.insertNode(firstLineWrapper);

        // middle lines
        elements.forEach((blockNode) => {
          const inlineNode = document.createElement(tagName);
          while (blockNode.firstChild) {
            inlineNode.append(blockNode.firstChild);
          }
          blockNode.append(inlineNode);
        });

        // last line
        if (isMultiLineSelection) {
          endRange.setStartBefore(lastBlockNode.firstChild);
          const endContent = endRange.extractContents();

          if (!!endContent.textContent) {
            // firstChild is the <p>, firstChild.firstChild is the content within
            while (endContent.firstChild) {
              lastLineWrapper.append(endContent.firstChild);
            }
          }

          endRange.insertNode(lastLineWrapper);
        }
      }
      flattenInlineElements(editor, tagName);
    }

    function makeBold(e) {
      e.preventDefault();
      wrapSelectionWithInlineElement("strong");
      helper.saveDebounce();
    }
    function makeItalic(e) {
      e.preventDefault();
      wrapSelectionWithInlineElement("em");
      helper.saveDebounce();
    }

    // NEW: Wrap the selected block elements in a list element.
    function wrapSelectionWithList(listType) {
      if (editor.lastSelection) {
        const range = editor.lastSelection;
        const blocks = getAllBlockElementsInSelection(editor, range, []);
        if (blocks.length === 0) {
          return;
        }
        const listElem = document.createElement(listType);
        // Insert the new list element before the first selected block.
        blocks[0].parentNode.insertBefore(listElem, blocks[0]);
        blocks.forEach((block) => {
          const li = document.createElement("li");
          li.innerHTML = block.innerHTML;
          listElem.appendChild(li);
          block.remove();
        });
      }
    }

    function replaceSelectedText(replacementText, htmlText) {
      const lines = replacementText.split("\n").filter((line) => {
        return line.length;
      });
      const htmlPasted = document.createElement('div');
      htmlPasted.innerHTML = htmlText.html;

      let sel, range;
      sel = document.getSelection() || window.getSelection();
      if (sel.rangeCount) {
        range = sel.getRangeAt(0);

        const elements = getAllBlockElementsInSelection(container, range, []);

        range.deleteContents();

        const mergeLogic = "merge with beginning and end";
        const newBlocksLogic = "when pasting multiple lines create new blocks";

        if (isEmpty(editor)) {

          container.innerHTML = "";

          while (htmlPasted.firstChild) {
            editor.append(htmlPasted.firstChild);
          }

          const lastTextNode = editor.lastElementChild.lastChild;
          const lastText = lastTextNode.textContent;

          let rangeOnLastElement = new Range();
          rangeOnLastElement.setStart(lastTextNode, 0);
          rangeOnLastElement.setEnd(lastTextNode, lastText.length);
          rangeOnLastElement.collapse(false);
          sel.removeAllRanges();
          sel.addRange(rangeOnLastElement);

          // if we pasted multiple lines, the pasted content will
          // determine the content element type
        } else if (elements.length > 0 && lines.length > 1) {
          // if we are inserting to the middle of a paragraph
          // and we are inserting more lines.
          // In this case we are creating a new paragraph from the extracted first part
          // of the paragraph, and attach the first line; we then insert the middle lines
          // as new paragraphs. Then at the end we create a new paragraph from the extracted
          // last part of the paragraph, and attach the last line to it.
          const isMultiLineSelection = elements.length > 1;
          const firstBlockNode = elements.shift();
          const lastBlockNode = elements.pop() || firstBlockNode;
          const startRange = range.cloneRange();
          const endRange = range.cloneRange();

          const pastingIntoList = firstBlockNode.tagName === 'LI' && (firstBlockNode.parentNode.tagName === 'UL' || firstBlockNode.parentNode.tagName === 'OL');
          const pastedAList = htmlPasted.firstChild?.tagName === 'UL' || htmlPasted.firstChild?.tagName === 'OL';

          // we need to make the htmlPasted the list items themselfs
          if (pastingIntoList && pastedAList) {
            const tempDiv = document.createElement('div');
            const ul = htmlPasted.firstChild;
            while (ul.firstChild) {
              tempDiv.append(ul.firstChild);
            }
            htmlPasted.innerHTML = tempDiv.innerHTML;
          }
          // if we select the complete paragraph (block element) in firefox all children are removed
          // so we have to add a dummy one.
          if (!firstBlockNode.firstChild) {
            const dummyTextNode = document.createTextNode("");
            firstBlockNode.append(dummyTextNode);
          }
          startRange.setStartBefore(firstBlockNode.firstChild);
          // this is needed because if the end of the selection is not 
          // in the starting container it will encapsulate the complete block element.
          // so if we have paragraphs, instead of getting a text node, we'd get the paragraph element
          if (isMultiLineSelection) {
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
          endRange.setEndAfter(lastBlockNode.lastChild);
          if (isMultiLineSelection) {
            endRange.setStartBefore(lastBlockNode.firstChild);
          }
          const startContent = startRange.extractContents();
          const endContent = endRange.extractContents();

          // we check if there is any content before the selection
          // if there is, we are adding them one by one to the new paragraph
          // note that if we are appending a child from a htmlFragement (startContent)
          // then it will be gone from the htmlFragement,
          // so we keep using the firstChild until there is any left.

          let endNode = firstBlockNode;
          let endTextNode = null;
          if (!!startContent.textContent) {
            const firstNode = document.createElement(firstBlockNode.tagName);

            while (startContent.firstChild) {
              firstNode.append(startContent.firstChild);
            }
            firstBlockNode.before(firstNode);
            firstNode.normalize();
            endNode = firstNode;
            endTextNode = firstNode.lastChild;
          }

          while (htmlPasted.firstChild) {
            if (htmlPasted.firstChild.nodeType == textNodeType) {
              htmlPasted.firstChild.remove();
              continue;
            }
            const newElemTagname = pastingIntoList ? 'LI' : htmlPasted.firstChild.tagName;
            const newElem = document.createElement(newElemTagname);
            while (htmlPasted.firstChild.firstChild) {
              newElem.append(htmlPasted.firstChild.firstChild);
            }
            htmlPasted.firstChild.remove();

            endNode.after(newElem);
            endNode = newElem;
          }

          endTextNode = lastTextNodeOf(endNode);

          if (!!endContent.textContent) {
            const closingNode = document.createElement(lastBlockNode.tagName);
            while (endContent.firstChild) {
              closingNode.append(endContent.firstChild);
            }
            endNode.after(closingNode);
            endNode = closingNode;
          }
          range.collapse(false);

          carretToTextNodeEnd(sel, endTextNode);
          firstBlockNode.remove();
          if (firstBlockNode != lastBlockNode) {
            lastBlockNode.remove();
          }
          endNode.normalize();
        } else if (elements.length > 0 && lines.length > 0) {
          // if we are inserting to the middle of a paragraph
          // and we are inserting more lines.
          // In this case we are creating a new paragraph from the extracted first part
          // of the paragraph, and attach the first line; we then insert the middle lines
          // as new paragraphs. Then at the end we create a new paragraph from the extracted
          // last part of the paragraph, and attach the last line to it.
          const isMultiLineSelection = elements.length > 1;
          const firstBlockNode = elements.shift();
          const lastBlockNode = elements.pop() || firstBlockNode;
          const startRange = range.cloneRange();
          const endRange = range.cloneRange();


          // this block is duplicated from above, so we should refactor it
          const pastingIntoUlist = firstBlockNode.tagName === 'LI' && firstBlockNode.parentNode.tagName === 'UL';
          const pastedAList = htmlPasted.firstChild?.tagName === 'UL';

          // we need to make the htmlPasted the list items themselfs
          if (pastingIntoUlist && pastedAList) {
            const tempDiv = document.createElement('div');
            const ul = htmlPasted.firstChild;
            while (ul.firstChild) {
              tempDiv.append(ul.firstChild);
            }
            htmlPasted.innerHTML = tempDiv.innerHTML;
          }

          const firstHtmlNodePasted = htmlPasted.firstChild;

          htmlPasted.firstChild.remove();

          // if we select the complete paragraph (block element) in firefox all children are removed
          // so we have to add a dummy one.
          if (!firstBlockNode.firstChild) {
            const dummyTextNode = document.createTextNode("");
            firstBlockNode.append(dummyTextNode);
          }
          startRange.setStartBefore(firstBlockNode.firstChild);
          // this is needed because if the end of the selection is not 
          // in the starting container it will encapsulate the complete block element.
          // so if we have paragraphs, instead of getting a text node, we'd get the paragraph element
          if (isMultiLineSelection) {
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
          endRange.setEndAfter(lastBlockNode.lastChild);
          if (isMultiLineSelection) {
            endRange.setStartBefore(lastBlockNode.firstChild);
          }
          const startContent = startRange.extractContents();
          const endContent = endRange.extractContents();

          const firstBlockNodeEmpty = isEmptyBlockElement(firstBlockNode);

          // pasting a list item into an empty list item is still an issue, so this needs a different solution
          // something like 'mergeLists' special case
          const firstNode = firstBlockNodeEmpty && !pastingIntoUlist
            ? document.createElement(firstHtmlNodePasted.tagName)
            : document.createElement(firstBlockNode.tagName);
          // we check if there is any content before the selection
          // if there is, we are adding them one by one to the new paragraph
          // note that if we are appending a child from a htmlFragement (startContent)
          // then it will be gone from the htmlFragement,
          // so we keep using the firstChild until there is any left.

          if (!!startContent.textContent) {
            while (startContent.firstChild) {
              firstNode.append(startContent.firstChild);
            }
          }

          while (firstHtmlNodePasted.firstChild) {
            firstNode.append(firstHtmlNodePasted.firstChild);
          }
          firstBlockNode.before(firstNode);

          let endNode = firstNode;
          let endTextNode = firstNode.lastChild;

          while (htmlPasted.firstChild) {
            if (htmlPasted.firstChild.nodeType == textNodeType) {
              htmlPasted.firstChild.remove();
              continue;
            }
            const elem = htmlPasted.firstChild.cloneNode(true);
            htmlPasted.firstChild.remove();
            endNode.after(elem);
            endNode = elem;
          }

          endTextNode = lastTextNodeOf(endNode);

          if (!!endContent.textContent) {
            while (endContent.firstChild) {
              endNode.append(endContent.firstChild);
            }
          }
          range.collapse(false);

          carretToTextNodeEnd(sel, endTextNode);
          firstBlockNode.remove();
          if (firstBlockNode != lastBlockNode) {
            lastBlockNode.remove();
          }
          firstNode.normalize();
          endNode.normalize();
        }
      }
    }

    function lastTextNodeOf(el) {
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
      let lastNode = null;
      while (walker.nextNode()) {
        lastNode = walker.currentNode;
      }
      if (!lastNode) {
        lastNode = document.createElement("br");
        el.append(lastNode);
      }
      return lastNode;
    }

    function textPaste(e) {
      e.preventDefault();
      flags.isPasting = true;
      const text = e.clipboardData.getData("text/plain").trim();
      let htmlText = e.clipboardData.getData("text/html");

      if (!htmlText) {
        htmlText = convertTextToHTML(text);
      }
      const htmlResult = htmlSanitizer(htmlText);
      replaceSelectedText(text, htmlResult);
      unsaved.style.display = "inline-block";
      flags.isPasting = false;
      helper.saveDebounce();
    }

    function hasAnySelectedTextNodes(container, range) {
      return !!getAllTextNodesInSelection(container, range, []).length;
    }

    function htmlSanitizer(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;

      const result = htmlWalker(tempDiv.childNodes);

      if (!result.blockElementCount) {
        result.html = `<p>${result.html}</p>`;
      }
      return result;
    }

    function tagReplacer(tagName) {
      if (tagName === "b" || tagName === "strong") {
        return "strong";
      }
      if (tagName === "i" || tagName === "em") {
        return "em";
      }
      else return tagName;
    }
    function htmlWalker(children, blockElementCount = 0) {
      let resultHtml = '';
      if (!children?.length) {
        return { html: '', blockElementCount };
      }

      for (let i = 0; i < children.length; i++) {
        const firstNode = i == 0;
        const lastNode = i == children.length - 1;
        const node = children[i];
        if (node.nodeType === Node.ELEMENT_NODE) {
          const blockElement = elementWhitelistBlockElements.includes(node.tagName);
          const inlineElement = elementWhitelistInlineElements.includes(node.tagName);

          // trim first and last node if empty
          if (firstNode && !node.innerHTML) {
            continue;
          }
          if (lastNode && !node.innerHTML) {
            continue;
          }
          if (blockElement) {
            blockElementCount++;
          }
          if (blockElement || inlineElement) {
            let tag = node.tagName.toLowerCase();
            tag = tagReplacer(tag);
            const result = htmlWalker(node.childNodes);
            blockElementCount += result.blockElementCount;
            let attributes = '';
            // TODO extend this and organize it better
            if (tag === "a") {
              attributes = ` href="${node.href}" target="_blank"`;
            }
            resultHtml += `<${tag}${attributes}>${result.html || '<br>'}</${tag}>`;
          } else if (node.childNodes.length) {
            // TODO if linebreak <br> we have to handle that somewhere here
            const result = htmlWalker(node.childNodes);
            blockElementCount += result.blockElementCount;
            resultHtml += result.html;
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
          resultHtml += node.nodeValue;
        }
      }

      return { html: resultHtml, blockElementCount };
    }

    function getAllTextNodesInSelection(selectionContainer, range, collectedTextNodes) {
      selectionContainer.childNodes.forEach((node) => {
        if (node.nodeType === textNodeType && range.intersectsNode(node)) {
          collectedTextNodes.push(node);
        } else {
          getAllTextNodesInSelection(node, range, collectedTextNodes);
        }
      });
      return collectedTextNodes;
    }

    function getAllBlockElementsInSelection(selectionContainer, range, collectedBlockNodes) {
      if (elementWhitelistBlockElementsInSelection.includes(selectionContainer?.tagName) && hasAnySelectedTextNodes(selectionContainer, range)) {
        collectedBlockNodes.push(selectionContainer);
      }
      selectionContainer.childNodes.forEach((node) => {
        if (elementWhitelistBlockElementsInSelection.includes(node.tagName) && hasAnySelectedTextNodes(node, range) && !collectedBlockNodes.includes(node)) {
          collectedBlockNodes.push(node);
        } else if (node.nodeType != textNodeType) {
          const newNodes = getAllBlockElementsInSelection(node, range, collectedBlockNodes);
        }
      });
      // if we are on an empty paragraph that only has a <br> we dont get it as an inline node
      // so we are adding it manually if this is the commonAncestorContainer
      if (!collectedBlockNodes.length && ["P", "LI"].includes(range.commonAncestorContainer.tagName) && isEmptyBlockElement(range.commonAncestorContainer)) {
        collectedBlockNodes.push(range.commonAncestorContainer);
      }
      return collectedBlockNodes;
    }

    function isEmptyBlockElement(element) {
      // Check each child node recursively
      for (let i = 0; i < element.childNodes.length; i++) {
        const node = element.childNodes[i];

        // Skip BR elements
        if (node.tagName === "BR") {
          continue;
        }

        // If it's a text node with content, element is not empty
        if (node.nodeType === textNodeType && node.textContent.trim()) {
          return false;
        }

        // For inline elements, check their contents recursively
        if (elementWhitelistInlineElements.includes(node.tagName)) {
          if (!isEmptyBlockElement(node)) {
            return false;
          }
          continue;
        }

        // For any other element type that has content
        if (node.textContent.trim()) {
          return false;
        }
      }
      return true;
    }

    function flattenInlineElements(container, tagName) {
      let inlineElements = container.querySelectorAll(tagName);
      inlineElements.forEach((elem) => {
        if (elem.parentNode.tagName.toLowerCase() == tagName) {
          replaceInlineWithTextNode(elem);
        }
      });

      // TOOD : use replaceInlineWithTextNode
      const elements = getInlineElementsToMerge(container, tagName);
      elements.forEach((elem) => {
        mergeToInlineElements(elem);
      });
    }

    function getInlineElementsToMerge(container, tagName) {
      let inlineElements = container.querySelectorAll(tagName);
      let elementsToMerge = [];
      inlineElements.forEach((elem) => {
        if (elem.nextSibling?.tagName?.toLowerCase() == tagName
          && elem.previousSibling?.tagName?.toLowerCase() !== tagName) {
          elementsToMerge.push(elem);
        }
      });
      return elementsToMerge;
    }

    function mergeToInlineElements(elem1) {
      const elem2 = elem1.nextSibling?.tagName?.toLowerCase() == elem1.tagName.toLowerCase()
        ? elem1.nextSibling
        : null;

      if (!elem2) {
        return;
      }

      while (elem2.firstChild) {
        elem1.append(elem2.firstChild);
      };

      nextElement = elem2.nextSibling?.tagName?.toLowerCase() == elem1.tagName.toLowerCase()
        ? elem2.nextSibling
        : null;
      elem2.remove();
      elem1.normalize();
      if (nextElement) {
        mergeToInlineElements(elem1, nextElement);
      }
    }

    // replaces bold/italic/etc with simple textNode
    function replaceInlineWithTextNode(element) {
      const newNode = document.createTextNode(element.textContent);
      const parentNode = element.parentNode;
      parentNode.replaceChild(newNode, element);
      parentNode.normalize();
    }

    // BEHAVIOURS >>>>>>>>>>>>>>>>>>

    dialogSaveButton.addEventListener("click", function () {
      loadFromText($("#content-text").value, editor);
      helper.saveDebounce();
      toggleDialog();
    });

    const convertButton = $("#convert-button");
    convertButton.addEventListener("click", function () {
      toggleDialog();
      convertTextAndDisplay();
    });
    dialogCloseButton.addEventListener("click", function () {
      toggleDialog();
    });

    boldButton.addEventListener("click", function (e) {
      makeBold(e);
    });
    italicButton.addEventListener("click", function (e) {
      makeItalic(e);
    });
    // NEW: List button event listeners
    ulButton.addEventListener("click", function (e) {
      e.preventDefault();
      wrapSelectionWithList("ul");
      helper.saveDebounce();
    });
    olButton.addEventListener("click", function (e) {
      e.preventDefault();
      wrapSelectionWithList("ol");
      helper.saveDebounce();
    });

    const bookButton = $("#book-button");
    bookButton.addEventListener("click", function () {
      page.classList.toggle("book");
      bookButton.classList.toggle("active");
    });

    const editButton = $("#edit-button");
    editButton.addEventListener("click", function () {
      editor.contentEditable = editor.contentEditable === "true" ? "false" : "true";
      editButton.classList.toggle("active");
    });

    const clearButton = $("#clear-button");
    clearButton.addEventListener("click", function () {
      clearContainer(editor);
    });

    const observer = new MutationObserver((mutationList) => {
      mutationList
        .filter((m) => m.type === "childList")
        .forEach((m) => {
          if (m.addedNodes.length) {
            // TODO probably not needed anymore and can be removed
            // helper.elementsCleanupDebounce(editor);
          }
          m.addedNodes.forEach((insertedElement) => {
            if (insertedElement.tagName === "SPAN") {
              const text = document.createTextNode(insertedElement.textContent);
              insertedElement.replaceWith(text);
            }
            // this is needed because if we are in a list and at the end there is a bold element
            // and we press enter, the bold element is not removed and we end up with a list item with an empty bold element
            // this causes issues at pasting and it is not desired
            if (insertedElement.tagName === "LI") {
              console.log("inserted LI", insertedElement);
              if (isEmptyBlockElement(insertedElement)) {
                insertedElement.innerHTML = "";
              }
            }
            if (insertedElement.tagName === "DIV") {
              const pContent = insertedElement.textContent
                ? document.createTextNode(insertedElement.textContent)
                : document.createElement("br");
              const paragraph = document.createElement("p");
              paragraph.append(pContent);
              insertedElement.replaceWith(paragraph);
              putCursorAtFirstElement(paragraph, 'br');
            }
          });
        });
    });
    observer.observe(editor, { childList: true, subtree: true });

    editor.addEventListener("paste", textPaste);

    editor.addEventListener("input", (event) => {
      // if (event.isComposing || event.keyCode === 229) {
      //   return;
      // }
      // // console.log("altKey", event.altKey);
      // // console.log("ctrlKey", event.ctrlKey);
      // // console.log("key", event.key);
      if (event.inputType === "deleteContentBackward") {
        console.log("Backspace");
        if (isEmpty(editor)) {
          clearContainer(editor);
        }
      }

      unsaved.style.display = "inline-block";
      helper.saveDebounce();
    });

    // add an event listener when text is selected inside the editor
    document.addEventListener("selectionchange", (event) => {
      let sel, range;
      sel = document.getSelection() || window.getSelection();
      if (sel.rangeCount) {
        range = sel.getRangeAt(0);
        const isSelectionInEditor = hasAnySelectedTextNodes(editor, range);
        // const newRange = range.cloneRange();
        if (isSelectionInEditor) {
          editor.lastSelection = range.cloneRange();
        }
        // console.log("isSelectionInEditor", isSelectionInEditor);
      }


    });

  </script>
</body>

</html>