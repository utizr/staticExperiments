<!DOCTYPE html>
<html>
<!-- css framework documentation -->
<!-- https://purecss.io/grids/ -->

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writer</title>

  <!-- <link rel="stylesheet" href="./css/icons/style.css" /> -->
  <link rel="stylesheet" href="./css/material/style.css" />
  <link rel="stylesheet" href="./css/page.css" />
  <link rel="stylesheet" href="./css/colors-light.css" />

  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“‹</text></svg>" />
</head>

<style></style>

<body>
  <div id="main-menu">
    <a id="hamburger" class="menu-button">
      <!-- <div class="lsf symbol">menu</div> -->
      <span class="material-symbols-outlined size-28">menu</span>
    </a>
    <div class="menu-separator"></div>

    <a id="title-button" class="menu-button">
      <!-- <div class="lsf symbol">bold</div> -->
      <span title="title" class="material-symbols-outlined size-28">title</span>
    </a>
    <a id="bold-button" class="menu-button">
      <!-- <div class="lsf symbol">bold</div> -->
      <span title="bold" class="material-symbols-outlined size-28">format_bold</span>
    </a>
    <a id="italic-button" class="menu-button">
      <!-- <div class="lsf symbol">italic</div> -->
      <span title="italic" class="material-symbols-outlined size-28">format_italic</span>
    </a>
    <!-- NEW: List buttons -->
    <a id="ul-button" class="menu-button">
      <!-- <i class="far fa-list-ul">list</i> -->
      <span title="bulletted list" class="material-symbols-outlined size-28">format_list_bulleted</span>
    </a>
    <a id="ol-button" class="menu-button">
      <!-- <div class="lsf symbol">list</div> -->
      <span title="numbered list" class="material-symbols-outlined size-28">format_list_numbered</span>
    </a>
    <a id="code-button" class="menu-button">
      <!-- <div class="lsf symbol">list</div> -->
      <span title="code" class="material-symbols-outlined size-28">code</span>
    </a>
    <a id="unsaved-button" class="menu-button">
      <!-- <div class="lsf symbol">etc</div> -->
      <span title="saving content" class="material-symbols-outlined size-28">sync</span>
    </a>
  </div>

  <div id="dialog" class="">
    <div id="dialog-button-container">
      <a id="dialog-close-button" class="dialog-button">
        <span class="material-symbols-outlined size-28">close</span>
      </a>
      <a id="dialog-save-button" class="dialog-button">
        <span class="material-symbols-outlined size-28">check</span>
      </a>
    </div>

    <div id="dialog-menu">
      <a id="edit-button" class="menu-button active">
        <span class="material-symbols-outlined size-28">edit</span>
      </a>
      <a id="convert-button" class="menu-button">
        <span class="material-symbols-outlined size-28">file_export</span>
      </a>
      <a id="clear-button" class="menu-button">
        <span class="material-symbols-outlined size-28">delete</span>
      </a>
    </div>
    <h3>Text Content</h3>
    <textarea name="content-text" id="content-text" cols="30" rows="10"></textarea>
    <h3>Last Pasted HTML (syles removed)</h3>
    <textarea name="content-text" id="last-pasted-html" cols="30" rows="10"></textarea>
    <h3>Sanitized HTML</h3>
    <textarea name="content-text" id="sanitized-html" cols="30" rows="10"></textarea>
  </div>

  <div id="page">

    <div id="container" contenteditable="true">
      <h1>Main title.</h1>
      <p>First paragraph which is awesome.</p>
      <h2>my title.</h2>
      <p>First paragraph which is awesome.</p>
      <p>Second paragraph which is amazing.</p>
      <p>Third paragraph which is great.</p>
      <p>One a paragraph <strong>bold</strong> which is awesome.</p>
      <p>Two b paragraph <strong>bold</strong> which is awesome.</p>
      <p>Three c paragraph <strong>bold</strong> which is awesome.</p>
      <h3>Footer title.</h3>
      <p>Third paragraph, <strong>bold</strong> and is even more awesome.</p>
      <p>4th paragraph, <em>italic</em> that is even more awesome.</p>
    </div>

    <i class="far fa-search"></i>

  </div>

  <script>
    function $(selector, element = document) {
      return element.querySelector(selector);
    }

    function $$(selectors, element = document) {
      return Array.from(element.querySelectorAll(selectors.join(",")));
    }

    const dialog = $("#dialog");
    const dialogCloseButton = $("#dialog-close-button");
    const dialogSaveButton = $("#dialog-save-button");
    const boldButton = $("#bold-button");
    const italicButton = $("#italic-button");
    // NEW: List buttons
    const ulButton = $("#ul-button");
    const olButton = $("#ol-button");
    const editor = $("#container");
    const page = $("#page");
    const unsaved = $("#unsaved-button");

    const textNodeType = 3;
    const elementWhitelistBlockElements = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'LI', 'PRE'];
    const elementWhitelistBlockElementsInSelection = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI'];
    const elementsCannotBeEmptyText = ['A', 'B', 'STRONG', 'I', 'EM', 'LI']
    const elementWhitelistInlineElements = ['B', 'A', 'STRONG', 'CODE', 'I', 'EM'];
    const brMarkerInText = "---";
    const flags = {
      isPasting: false,
    };

    // HELPERS >>>>>>>>>>>>>>>>>>
    const helper = {
      ini() {
        this.saveDebounce = this.saveDebounce();
        this.elementsCleanupDebounce = this.elementsCleanupDebounce();
      },
      debounce: function (fn, delay) {
        var timer = null;
        return function () {
          var context = this,
            args = arguments;
          clearTimeout(timer);
          timer = setTimeout(function () {
            fn.apply(context, args);
          }, delay);
        };
      },
      saveDebounce: function () {
        return this.debounce(() => {
          localStorage.setItem("book", convertToText(Array.from(editor.children)));
          unsaved.style.display = "none";
        }, 1000)
      },
      // needed for removing empty inline elements after modification of the editor
      // unfortunately cannot be done on a mutation observer because in firefox does not seem to work properly
      // at least the empty b is not created, and we can also not observe a text node being removed from the b element (?)
      elementsCleanupDebounce: function (containerDom) {
        return this.debounce((containerDom) => {
          if (flags.isPasting) {
            return;
          }
          inlineElements = $$(elementWhitelistInlineElements, containerDom);

          inlineElements.forEach((inlineElement) => {
            if (!inlineElement.textContent && inlineElement.parentNode) {
              const parentNode = inlineElement.parentNode;
              inlineElement.remove();
              if (!parentNode.firstChild) {
                parentNode.innerHTML = "<br/>";
              }
            }
          });

          blockElements = $$(elementWhitelistBlockElements, containerDom);

          blockElements.forEach((blockElement) => {
            if (!blockElement.textContent && !blockElement.firstChild) {
              blockElement.remove();
            }
          });
        }, 500)
      },
      encodeHTMLEntities(rawStr) {
        return rawStr.replace(/[\u00A0-\u9999<>\&]/g, (i) => `&#${i.charCodeAt(0)};`);
      },
    }

    helper.ini();

    function tagReplacer(tagName) {
      if (tagName === "b" || tagName === "strong") {
        return "strong";
      }
      if (tagName === "i" || tagName === "em") {
        return "em";
      }
      if (tagName === "span") {
        return "p";
      }
      else return tagName;
    }

    function escapeHtml(text) {
      if (!text) return text;
      return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    function unescapeHtml(text) {
      if (!text) return text;
      return text
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/&#039;/g, "'")
        .replace(/&amp;/g, "&"); // Always replace ampersand last to avoid double-decoding
    }

    // VIEW METHODS <<<<<<<<<<<<<<<<<<<<<
    function toggleDialog() {
      dialog.classList.toggle("active");
    }

    // STORAGE METHODS <<<<<<<<<<<<<<<<<<<<<
    function loadDataOnPageLoad() {
      const book = localStorage.getItem("book");
      if (!book) {
        return;
      }
      loadFromText(book, editor);
    }
    // TODO turn this back on after testing
    loadDataOnPageLoad();

    // ENCODER DECODER <<<<<<<<<<<<<<<<<<<<<

    // EXTENDED loadFromText: now handles lists!

    function isValidHttpUrl(text) {
      if (!text.match(/^https?:\/\/.+/)) {
        return false;
      }

      try {
        new URL(text);
      } catch (_) {
        return false;
      }

      return true;
    }

    function loadFromText(text, container) {
      container.innerHTML = convertTextToHTML(text);
    }
    /**
     * Main conversion function
     */
    function convertTextToHTML(text, insideList = false) {
      // 1. Check for single URL
      if (isValidHttpUrl(text)) {
        return `<a href="${text}" target="_blank">${text}</a>`;
      }

      // 2. Define Regex for Code Blocks (Fence)
      // Logic:
      // (?:^|\n)      -> Match Start of String OR a Newline (non-capturing)
      // ```           -> Match opening fence
      // [\w-]* -> Match optional language (e.g. js, css)
      // \r?\n         -> Match newline immediately after fence (Required)
      // [\s\S]*?      -> Match any content (lazy)
      // \r?\n```      -> Match closing fence (must be on a new line)
      const codeBlockRegex = /((?:^|\n)```[\w-]*\r?\n[\s\S]*?\r?\n```)/g;

      // 3. Split text into segments
      // Because we wrapped the entire pattern in (), split will include the code blocks in the array
      const segments = text.split(codeBlockRegex);

      // 4. Process each segment
      const processedSegments = segments.map((segment) => {
        // Check if this segment looks like a code block
        // It might start with a newline if it was in the middle of the text
        const codeMatch = segment.match(/^(?:\r?\n)?```([\w-]*)\r?\n([\s\S]*?)\r?\n```$/);

        if (codeMatch) {
          const language = codeMatch[1];
          const codeContent = codeMatch[2];

          // Encode HTML entities to prevent rendering inside the code block
          const encodedCode = helper.encodeHTMLEntities(codeContent);

          const langClass = language ? ` class="language-${language}"` : "";
          return `<pre><code${langClass}>${encodedCode}</code></pre>`;
        }

        // Fallback: Treat as Standard Markdown
        if (segment.trim() === "") return "";

        return parseStandardBlock(segment, insideList);
      });

      return processedSegments.join("\n");
    }

    /**
     * Extracted the original block parsing logic into a separate helper
     * to allow it to be called for segments between code blocks.
     */
    function parseStandardBlock(text, insideList) {
      const blocks = text.split("\n\n");

      const blockType = {
        "#": "H1",
        "##": "H2",
        "###": "H3",
        "####": "H4",
        "#####": "H5",
        "######": "H6",
      };

      const blockElements = blocks.map((block) => {
        // Handle empty blocks that might occur from splitting
        if (!block.trim()) return "";

        const lines = block.split("\n");

        // Check if this block is a list block
        if (/^(\-|\*|\+|\d+\.)\s+/.test(lines[0]) && !insideList) {
          return parseListBlock(lines);
        } else {
          let blockTypeKey = lines[0].match(/^#+/);
          let blockTypeValue = blockType[blockTypeKey] || "P";

          if (blockType[blockTypeKey]) {
            lines[0] = lines[0].replace(/^#+/, "").trim();
          }

          // Handle specific BR marker if defined in your context
          if (typeof brMarkerInText !== 'undefined' && blockTypeValue === "P" && lines[0] === brMarkerInText && lines.length === 1) {
            return "<p><br/></p>";
          }

          const htmlLines = lines.map((line) => {
            return parseInlineMarkdown(line);
          });
          const blockContent = htmlLines.join("<br>");

          if (insideList && blockTypeValue === "P") {
            return blockContent;
          }
          return `<${blockTypeValue}>${blockContent}</${blockTypeValue}>`;
        }
      });

      return blockElements.join("\n");
    }

    // --- The rest of your existing functions (parseListBlock, buildNestedList, parseInlineMarkdown) ---
    // --- Keep them exactly as they were in your question, ensuring 'helper' is defined ---

    function parseListBlock(lines) {
      // Parse nested lists by analyzing indentation levels
      const listItems = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const listMatch = line.match(/^(\s*)(\-|\*|\+|\d+\.)\s+(.*)$/);

        if (listMatch) {
          const [, indentation, marker, content] = listMatch;
          const normalizedIndent = indentation.replace(/\t/g, '  ');
          const level = Math.floor(normalizedIndent.length / 2);
          const isOrdered = /^\d+\./.test(marker);

          if (level > 1 && !listItems.length) {
            const lastItem = listItems[listItems.length - 1];
            lastItem.content += '\n' + line.trim();
            continue;
          }
          listItems.push({
            level,
            indentation,
            isOrdered,
            content: content.trim(),
            originalLine: line
          });
        } else if (line.trim() === '') {
          continue;
        } else {
          if (listItems.length > 0) {
            const lastItem = listItems[listItems.length - 1];
            lastItem.content += '\n' + line.trim();
          }
        }
      }

      return buildNestedList(listItems);
    }

    function buildNestedList(items, startLevel = 0) {
      if (items.length === 0) return '';

      const result = [];
      let i = 0;

      while (i < items.length) {
        const currentItem = items[i];

        if (currentItem.level === startLevel) {
          const levelGroups = [];
          let currentGroup = {
            isOrdered: currentItem.isOrdered,
            items: []
          };

          let j = i;
          while (j < items.length && items[j].level >= startLevel) {
            if (items[j].level === startLevel) {
              if (items[j].isOrdered !== currentGroup.isOrdered && currentGroup.items.length > 0) {
                levelGroups.push(currentGroup);
                currentGroup = {
                  isOrdered: items[j].isOrdered,
                  items: []
                };
              }

              const nestedItems = [];
              let k = j + 1;
              while (k < items.length && items[k].level > startLevel) {
                nestedItems.push(items[k]);
                k++;
              }

              const nestedList = buildNestedList(nestedItems, startLevel + 1);
              const itemContent = convertTextToHTML(items[j].content, true);

              currentGroup.items.push({
                content: itemContent,
                nestedList: nestedList
              });

              j = k - 1;
            }
            j++;
          }

          if (currentGroup.items.length > 0) {
            levelGroups.push(currentGroup);
          }

          levelGroups.forEach(group => {
            const listTag = group.isOrdered ? "OL" : "UL";
            const groupItems = group.items.map(item => {
              if (item.nestedList) {
                return `<li>${item.content}${item.nestedList}</li>`;
              } else {
                return `<li>${item.content}</li>`;
              }
            }).join('\n');
            result.push(`<${listTag}>${groupItems}</${listTag}>`);
          });

          i = j;
        } else {
          i++;
        }
      }

      return result.join('\n');
    }

    function parseInlineMarkdown(text) {
      let html = text;
      const codeBlocks = [];
      // Parse inline code blocks: 
      // 1. (`+)       -> Capture delimiter (one or more backticks)
      // 2. ([\s\S]*?) -> Capture content (non-greedy)
      // 3. (?<!`)     -> Negative Lookbehind: Ensure the closer is NOT preceded by a backtick
      // 4. \1         -> Match the exact same delimiter captured in group 1
      // 5. (?!`)      -> Negative Lookahead: Ensure the closer is NOT followed by a backtick
      html = html.replace(/(`+)([\s\S]*?)(?<!`)\1(?!`)/g, (match, delimiter, content) => {
        let code = content;

        // Optional: CommonMark spec says to strip outer space if present on both sides
        // e.g. `` ` `` renders as ` (a single backtick)
        if (code.startsWith(" ") && code.endsWith(" ") && code.trim().length > 0) {
          code = code.substring(1, code.length - 1);
        }

        // we are first replacing the code blocks with a placeholder, so that code inside it doesn ot disturb other elements.
        // for example if it has underscore in it, it might be interpreted as italic formating.
        const index = codeBlocks.length + 1;
        const placeHolder = `<code::${index}/>`;
        codeBlocks.push({
          placeHolder,
          code: `<code>${helper.encodeHTMLEntities(code)}</code>`,
        });
        return placeHolder;
      });

      // Parse images
      html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, altText, src) => {
        return `<img src="${src}" alt="${altText}" />`;
      });

      // Parse links
      html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, textContent, href) => {
        return `<a href="${href}" target="_blank">${helper.encodeHTMLEntities(textContent)}</a>`;
      });

      // Bold Italic ***
      html = html.replace(/\*\*\*(?!\s)([^*]+?)(?<!\s)\*\*\*/g, (match, p1) => {
        return `<em><strong>${p1}</strong></em>`;
      });

      // Bold **
      html = html.replace(/(?<!\*)\*\*(?!\s)([^*]+?)(?<!\s)\*\*(?!\*)/g, (match, p1) => {
        return `<strong>${p1}</strong>`;
      });

      // Italic *
      html = html.replace(/(?<!\*)\*(?!\s)([^*]+?)(?<!\s)\*(?!\*)/g, (match, p1) => {
        return `<em>${p1}</em>`;
      });

      // Bold Italic ___
      html = html.replace(/___(?!\s)([^_]+?)(?<!\s)___/g, (match, p1) => {
        return `<em><strong>${p1}</strong></em>`;
      });

      // Bold __
      html = html.replace(/(?<!_)__(?!\s)([^_]+?)(?<!\s)__(?!_)/g, (match, p1) => {
        return `<strong>${p1}</strong>`;
      });

      // Italic _
      html = html.replace(/(?<!_)_(?!\s)([^_]+?)(?<!\s)_(?!_)/g, (match, p1) => {
        return `<em>${p1}</em>`;
      });

      codeBlocks.forEach((codeBlock) => {
        html = html.replace(codeBlock.placeHolder, codeBlock.code);
      });
      return html;
    }
    // PASTE handler
    function convertToText(nodes, insideList = false, level = 0) {

      let joiner = "\n\n";
      if (insideList) {
        joiner = ""
      }
      let textParts = nodes
        .map((block) => {
          // NEW: Handle UL lists
          // if statement when the block is an textnode
          if (block.nodeType === textNodeType && !insideList) {
            const textContent = block.textContent.replace(/\n/g, '');
            return textContent;
          }
          if (block.tagName === "UL") {
            return Array.from(block.children)
              .map(li => {
                const itemText = convertListItemToText(li, level, '-');
                return itemText;
              })
              .join("\n");
          }
          // NEW: Handle OL lists
          else if (block.tagName === "OL") {
            return Array.from(block.children)
              .map((li, index) => {
                const listMarker = `${index + 1}.`
                const itemText = convertListItemToText(li, level, listMarker);
                return itemText;
              })
              .join("\n");
          }
          else if (block.tagName?.startsWith("H")) {
            const prefix = "#".repeat(parseInt(block.tagName[1])) + " ";
            return prefix + convertInlineToText(Array.from(block.childNodes));
          }
          else if (block.tagName == "PRE") {
            if (block.childNodes[0].tagName == 'CODE') {
              const prefix = "```\n";
              const postfix = "\n```";
              // return prefix + convertInlineToText(Array.from(block.childNodes[0].childNodes)) + postfix;
              return prefix + unescapeHtml(block.childNodes[0].innerHTML) + postfix;
            }
          }
          else {
            if (block.tagName?.startsWith("H")) {
              const prefix = "#".repeat(parseInt(block.tagName[1])) + " ";
              return prefix + convertInlineToText(Array.from(block.childNodes));
            }
            // this is the case where we only have a normal text node if we are inside a list
            // or other inline nodes
            if (insideList) {
              return convertInlineToText(Array.from(block.childNodes));
            }
            // here we have a p element, so we dont have any prefix
            // we just loop over it's children and treat them as inline elements
            const nodeContent = convertInlineToText(Array.from(block.childNodes));
            // if we are in an empty P element, we just add an empty space
            if (block.tagName === "P" && !nodeContent.trim()) {
              return brMarkerInText;
            }
            return nodeContent;
          }
        });

      textParts = textParts.filter((part) => {
        return part?.length > 0;
      });
      const text = textParts.join(joiner);
      return text;
    }

    function getLastTextNode(node) {
      if (!node) return null;

      // 1. If the node itself is a non-empty text node, return it
      if (node.nodeType === Node.TEXT_NODE) {
        return node;
      }

      // 2. If it's an element, loop through children backwards
      if (node.childNodes) {
        for (let i = node.childNodes.length - 1; i >= 0; i--) {
          const textNode = getLastTextNode(node.childNodes[i]);
          if (textNode) {
            return textNode;
          }
        }
      }

      return null;
    }

    function convertListItemToText(li, level, listMarker) {
      const textParts = [];
      const nestedLists = [];

      const firstListIndent = "  ".repeat(level);
      const indent = "  ".repeat(level + 1);

      let output = `${firstListIndent}${listMarker} `;

      // Process each child node of the list item
      Array.from(li.childNodes).forEach(child => {
        if (child.nodeType === textNodeType) {
          // Text node - add the text content
          const text = child.textContent.replace(/\n/g, '');
          if (text) {
            textParts.push(text);
          }
          output += text;
        } else if (child.tagName === 'UL' || child.tagName === 'OL') {
          // Nested list - convert it with proper indentation
          // This should be treated as a block element, not inline content
          const nestedList = convertToText([child], true, level + 1);
          if (nestedList) {
            nestedLists.push(nestedList);
          }
        } else if (child.tagName === 'P') {
          output += `\n${indent}`;
          // The LI only contains a P element
          const inlineText = convertInlineToText(Array.from(child.childNodes));
          if (inlineText) {
            textParts.push(inlineText);
          }
          output += inlineText;
        } else if (child.tagName == 'BR') {
          output += `\n${indent}`;
        } else {
          // Other inline elements (bold, italic, etc.)
          const inlineText = convertInlineToText([child]);
          if (inlineText) {
            textParts.push(inlineText);
          }
          output += inlineText;
        }
      });

      // Combine text content
      let result = textParts.join('');

      // Add nested lists with proper line breaks and indentation
      if (nestedLists.length > 0) {
        // Add a line break before the nested list
        // The nested list already has the correct indentation from convertToText
        result += '\n' + nestedLists.join('\n');
        output += '\n' + nestedLists.join('\n');
      }

      return output;
    }

    function convertInlineToText(inlineElements) {
      const text = inlineElements
        .map((ie) => {
          let prefix = "";
          let postfix = "";
          if (ie.tagName == 'B' || ie.tagName == 'STRONG') {
            prefix = "**";
            postfix = "**";
            return prefix + convertInlineToText(Array.from(ie.childNodes)) + postfix;
          }
          if (ie.tagName == 'I' || ie.tagName == 'EM') {
            prefix = "_";
            postfix = "_";
            return prefix + convertInlineToText(Array.from(ie.childNodes)) + postfix;
          }
          if (ie.tagName == 'CODE') {
            prefix = "`";
            postfix = "`";
            return prefix + convertInlineToText(Array.from(ie.childNodes)) + postfix;
          }
          if (ie.tagName == 'A') {
            return `[${ie.textContent.replace(/\n/g, '')}](${ie.href})`;
          }
          return ie.textContent.replace(/\n/g, '');
        })
        .join("");

      return text;
    }

    function convertTextAndDisplay() {
      $("#content-text").value = convertToText(Array.from(editor.children));
    }

    function isEmpty(editor) {
      if (editor.children.length === 1) {
        const p = editor.children[0];
        if (editor.firstChild.textContent.trim() === "") {
          return true;
        }
      }
      if (!editor.children.length) {
        return true;
      }
      return false;
    }

    function clearContainer(container) {
      container.innerHTML = `<p><br/></p>`;
    }
    function loadDefaultData(container) {
      // container.innerHTML = `<p><br/></p>`;
      loadFromText(`
# Main title.

First paragraph which is awesome.

## my title.

One two three.

link: [/lab/editor-commands.html](./lab/editor-commands.html)

Four five six.

First paragraph which is awesome.

Second paragraph which is amazing.

Third paragraph which is great.

One a paragraph **bold** which is awesome.

Two b paragraph **bold** which is awesome.

Three c paragraph **bold** which is awesome.

- List item **one** ends here.
- List item **two** ends here.
  - Nested item 2.1
  - Nested item 2.2
    - Deeply nested item 2.2.1
    - Deeply nested item 2.2.2
- List item **three** ends here.
- List item **four** ends here.

1. Ordered list item one
2. Ordered list item two
  1. Nested ordered item 2.1
  2. Nested ordered item 2.2
    1. Deeply nested ordered item 2.2.1
    2. Deeply nested ordered item 2.2.2
3. Ordered list item three

Mixed list example:

- Unordered item 1
1. Ordered item 1
2. Ordered item 2
  - Nested unordered in ordered
  - Another nested unordered
- Back to unordered
  - Nested unordered
    1. Deeply nested ordered
    2. Another deeply nested ordered

### Footer title.

Third paragraph, **bold** and is even more awesome.

4th paragraph, *italic* that is even more awesome.
        `.trim(), editor);

      helper.saveDebounce();
    }

    function putCursorAtFirstElement(rootElement, tagName) {
      const firstElement = rootElement.querySelector(tagName);
      const sel = document.getSelection() || window.getSelection();
      const rangeOnFirstElement = new Range();
      rangeOnFirstElement.selectNode(firstElement);
      rangeOnFirstElement.collapse(false);
      sel.removeAllRanges();
      sel.addRange(rangeOnFirstElement);
      return rangeOnFirstElement
    }

    function carretToNodeEnd(node) {
      const sel = document.getSelection() || window.getSelection();
      const lastTextNode = getLastTextNodeOfElement(node);
      carretToTextNodeEnd(sel, lastTextNode);
    }

    function carretToTextNodeEnd(sel, textNode) {
      let rangeOnLastElement = new Range();
      rangeOnLastElement.setStart(textNode, 0);
      rangeOnLastElement.setEnd(textNode, textNode.textContent.length);
      rangeOnLastElement.collapse(false);
      sel.removeAllRanges();
      sel.addRange(rangeOnLastElement);
    }

    function wrapSelectionWithInlineElement(tagName) {
      if (editor.lastSelection) {
        range = editor.lastSelection;
        const firstLineWrapper = document.createElement(tagName);
        const lastLineWrapper = document.createElement(tagName);

        const elements = getAllBlockElementsInSelection(editor, range, []);
        const isMultiLineSelection = elements.length > 1;

        const firstBlockNode = elements.shift();
        const lastBlockNode = elements.pop() || firstBlockNode;

        let startRange = range.cloneRange();
        const endRange = range.cloneRange();

        // first line
        if (isMultiLineSelection) {
          startRange.setEndAfter(firstBlockNode.lastChild);
        } else {
          // first for complete block selection, where it would not select the content
          // of the node, but the complete node itself
          const contentCopy = startRange.cloneContents();
          if (contentCopy.firstChild.tagName === firstBlockNode.tagName) {
            startRange.setStartBefore(firstBlockNode.firstChild);
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
        }

        const startContent = startRange.extractContents();

        if (!!startContent.textContent) {
          // firstChild is the <p>, firstChild.firstChild is the content within
          while (startContent.firstChild) {
            firstLineWrapper.append(startContent.firstChild);
          }
        }

        startRange.insertNode(firstLineWrapper);

        // middle lines
        elements.forEach((blockNode) => {
          const inlineNode = document.createElement(tagName);
          while (blockNode.firstChild) {
            inlineNode.append(blockNode.firstChild);
          }
          blockNode.append(inlineNode);
        });

        // last line
        if (isMultiLineSelection) {
          endRange.setStartBefore(lastBlockNode.firstChild);
          const endContent = endRange.extractContents();

          if (!!endContent.textContent) {
            // firstChild is the <p>, firstChild.firstChild is the content within
            while (endContent.firstChild) {
              lastLineWrapper.append(endContent.firstChild);
            }
          }

          endRange.insertNode(lastLineWrapper);
        }
      }
      flattenInlineElements(editor, tagName);
    }

    function makeBold(e) {
      e.preventDefault();
      wrapSelectionWithInlineElement("strong");
      helper.saveDebounce();
    }
    function makeItalic(e) {
      e.preventDefault();
      wrapSelectionWithInlineElement("em");
      helper.saveDebounce();
    }

    // NEW: Wrap the selected block elements in a list element.
    function wrapSelectionWithList(listType) {
      if (editor.lastSelection) {
        const range = editor.lastSelection;
        const blocks = getAllBlockElementsInSelection(editor, range, []);
        if (blocks.length === 0) {
          return;
        }
        const listElem = document.createElement(listType);
        // Insert the new list element before the first selected block.
        blocks[0].parentNode.insertBefore(listElem, blocks[0]);
        blocks.forEach((block) => {
          const li = document.createElement("li");
          li.innerHTML = block.innerHTML;
          listElem.appendChild(li);
          block.remove();
        });
        carretToNodeEnd(listElem)
      }
    }

    function replaceSelectedText(replacementText, htmlText) {
      const lines = replacementText.split("\n").filter((line) => {
        return line.length;
      });
      const htmlPasted = document.createElement('div');
      htmlPasted.innerHTML = htmlText.html;

      let sel, range;
      sel = document.getSelection() || window.getSelection();
      if (sel.rangeCount) {
        range = sel.getRangeAt(0);

        const elements = getAllBlockElementsInSelection(container, range, []);

        range.deleteContents();

        const mergeLogic = "merge with beginning and end";
        const newBlocksLogic = "when pasting multiple lines create new blocks";

        if (isEmpty(editor)) {

          container.innerHTML = "";

          while (htmlPasted.firstChild) {
            editor.append(htmlPasted.firstChild);
          }

          const lastTextNode = getLastTextNode(editor);
          const lastText = lastTextNode.textContent;

          let rangeOnLastElement = new Range();
          rangeOnLastElement.setStart(lastTextNode, 0);
          rangeOnLastElement.setEnd(lastTextNode, lastText.length);
          rangeOnLastElement.collapse(false);
          sel.removeAllRanges();
          sel.addRange(rangeOnLastElement);

          // if we pasted multiple lines, the pasted content will
          // determine the content element type
        } else if (elements.length > 0 && lines.length > 1) {
          // if we are inserting to the middle of a paragraph
          // and we are inserting more lines.
          // In this case we are creating a new paragraph from the extracted first part
          // of the paragraph, and attach the first line; we then insert the middle lines
          // as new paragraphs. Then at the end we create a new paragraph from the extracted
          // last part of the paragraph, and attach the last line to it.
          const isMultiLineSelection = elements.length > 1;
          const firstBlockNode = elements.shift();
          const lastBlockNode = elements.pop() || firstBlockNode;
          const startRange = range.cloneRange();
          const endRange = range.cloneRange();

          const pastingIntoList = firstBlockNode.tagName === 'LI' && (firstBlockNode.parentNode.tagName === 'UL' || firstBlockNode.parentNode.tagName === 'OL');
          const pastedAList = htmlPasted.firstChild?.tagName === 'UL' || htmlPasted.firstChild?.tagName === 'OL';

          // we need to make the htmlPasted the list items themselfs
          if (pastingIntoList && pastedAList) {
            const tempDiv = document.createElement('div');
            const ul = htmlPasted.firstChild;
            while (ul.firstChild) {
              tempDiv.append(ul.firstChild);
            }
            htmlPasted.innerHTML = tempDiv.innerHTML;
          }
          // if we select the complete paragraph (block element) in firefox all children are removed
          // so we have to add a dummy one.
          if (!firstBlockNode.firstChild) {
            const dummyTextNode = document.createTextNode("");
            firstBlockNode.append(dummyTextNode);
          }
          startRange.setStartBefore(firstBlockNode.firstChild);
          // this is needed because if the end of the selection is not 
          // in the starting container it will encapsulate the complete block element.
          // so if we have paragraphs, instead of getting a text node, we'd get the paragraph element
          if (isMultiLineSelection) {
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
          endRange.setEndAfter(lastBlockNode.lastChild);
          if (isMultiLineSelection) {
            endRange.setStartBefore(lastBlockNode.firstChild);
          }
          const startContent = startRange.extractContents();
          const endContent = endRange.extractContents();

          // we check if there is any content before the selection
          // if there is, we are adding them one by one to the new paragraph
          // note that if we are appending a child from a htmlFragement (startContent)
          // then it will be gone from the htmlFragement,
          // so we keep using the firstChild until there is any left.

          let endNode = firstBlockNode;
          let endTextNode = null;
          if (!!startContent.textContent) {
            const firstNode = document.createElement(firstBlockNode.tagName);

            while (startContent.firstChild) {
              firstNode.append(startContent.firstChild);
            }
            firstBlockNode.before(firstNode);
            firstNode.normalize();
            endNode = firstNode;
            endTextNode = firstNode.lastChild;
          }

          while (htmlPasted.firstChild) {
            if (htmlPasted.firstChild.nodeType == textNodeType) {
              htmlPasted.firstChild.remove();
              continue;
            }
            const newElemTagname = pastingIntoList ? 'LI' : htmlPasted.firstChild.tagName;
            const newElem = document.createElement(newElemTagname);
            while (htmlPasted.firstChild.firstChild) {
              newElem.append(htmlPasted.firstChild.firstChild);
            }
            htmlPasted.firstChild.remove();

            endNode.after(newElem);
            endNode = newElem;
          }

          endTextNode = lastTextNodeOf(endNode);

          if (!!endContent.textContent) {
            const closingNode = document.createElement(lastBlockNode.tagName);
            while (endContent.firstChild) {
              closingNode.append(endContent.firstChild);
            }
            endNode.after(closingNode);
            endNode = closingNode;
          }
          range.collapse(false);

          carretToTextNodeEnd(sel, endTextNode);
          firstBlockNode.remove();
          if (firstBlockNode != lastBlockNode) {
            lastBlockNode.remove();
          }
          endNode.normalize();
        } else if (elements.length > 0 && lines.length > 0) {
          // if we are inserting to the middle of a paragraph
          // and we are inserting more lines.
          // In this case we are creating a new paragraph from the extracted first part
          // of the paragraph, and attach the first line; we then insert the middle lines
          // as new paragraphs. Then at the end we create a new paragraph from the extracted
          // last part of the paragraph, and attach the last line to it.
          const isMultiLineSelection = elements.length > 1;
          const firstBlockNode = elements.shift();
          const lastBlockNode = elements.pop() || firstBlockNode;
          const startRange = range.cloneRange();
          const endRange = range.cloneRange();


          // this block is duplicated from above, so we should refactor it
          const pastingIntoUlist = firstBlockNode.tagName === 'LI' && firstBlockNode.parentNode.tagName === 'UL';
          const pastedAList = htmlPasted.firstChild?.tagName === 'UL';

          // we need to make the htmlPasted the list items themselfs
          if (pastingIntoUlist && pastedAList) {
            const tempDiv = document.createElement('div');
            const ul = htmlPasted.firstChild;
            while (ul.firstChild) {
              tempDiv.append(ul.firstChild);
            }
            htmlPasted.innerHTML = tempDiv.innerHTML;
          }

          const firstHtmlNodePasted = htmlPasted.firstChild;

          htmlPasted.firstChild.remove();

          // if we select the complete paragraph (block element) in firefox all children are removed
          // so we have to add a dummy one.
          if (!firstBlockNode.firstChild) {
            const dummyTextNode = document.createTextNode("");
            firstBlockNode.append(dummyTextNode);
          }
          startRange.setStartBefore(firstBlockNode.firstChild);
          // this is needed because if the end of the selection is not 
          // in the starting container it will encapsulate the complete block element.
          // so if we have paragraphs, instead of getting a text node, we'd get the paragraph element
          if (isMultiLineSelection) {
            startRange.setEndAfter(firstBlockNode.lastChild);
          }
          endRange.setEndAfter(lastBlockNode.lastChild);
          if (isMultiLineSelection) {
            endRange.setStartBefore(lastBlockNode.firstChild);
          }
          const startContent = startRange.extractContents();
          const endContent = endRange.extractContents();

          const firstBlockNodeEmpty = isEmptyBlockElement(firstBlockNode);

          // pasting a list item into an empty list item is still an issue, so this needs a different solution
          // something like 'mergeLists' special case
          const firstNode = firstBlockNodeEmpty && !pastingIntoUlist
            ? document.createElement(firstHtmlNodePasted.tagName)
            : document.createElement(firstBlockNode.tagName);
          // we check if there is any content before the selection
          // if there is, we are adding them one by one to the new paragraph
          // note that if we are appending a child from a htmlFragement (startContent)
          // then it will be gone from the htmlFragement,
          // so we keep using the firstChild until there is any left.

          if (!!startContent.textContent) {
            while (startContent.firstChild) {
              firstNode.append(startContent.firstChild);
            }
          }

          while (firstHtmlNodePasted.firstChild) {
            firstNode.append(firstHtmlNodePasted.firstChild);
          }
          firstBlockNode.before(firstNode);

          let endNode = firstNode;
          let endTextNode = firstNode.lastChild;

          while (htmlPasted.firstChild) {
            if (htmlPasted.firstChild.nodeType == textNodeType) {
              htmlPasted.firstChild.remove();
              continue;
            }
            const elem = htmlPasted.firstChild.cloneNode(true);
            htmlPasted.firstChild.remove();
            endNode.after(elem);
            endNode = elem;
          }

          endTextNode = lastTextNodeOf(endNode);

          if (!!endContent.textContent) {
            while (endContent.firstChild) {
              endNode.append(endContent.firstChild);
            }
          }
          range.collapse(false);

          carretToTextNodeEnd(sel, endTextNode);
          firstBlockNode.remove();
          if (firstBlockNode != lastBlockNode) {
            lastBlockNode.remove();
          }
          firstNode.normalize();
          endNode.normalize();
        }
      }
    }

    function lastTextNodeOf(el) {
      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT)
      let lastNode = null;
      while (walker.nextNode()) {
        lastNode = walker.currentNode;
      }
      if (!lastNode) {
        lastNode = document.createElement("br");
        el.append(lastNode);
      }
      return lastNode;
    }

    function textPaste(e) {
      e.preventDefault();
      flags.isPasting = true;
      const text = e.clipboardData.getData("text/plain").trim();
      let htmlText = e.clipboardData.getData("text/html");

      $("#last-pasted-html").value = htmlText.replace(
        /\s*style\s*=\s*(?:"[^"]*"|'[^']*'|[^\s>]+)/gi,
        ''
      );
      if (!htmlText) {
        htmlText = convertTextToHTML(text);
      }
      const htmlResult = htmlSanitizer(htmlText);
      $("#sanitized-html").value = htmlResult.html;
      replaceSelectedText(text, htmlResult);
      unsaved.style.display = "inline-block";
      flags.isPasting = false;
      helper.saveDebounce();
    }

    function hasAnySelectedTextNodes(container, range) {
      return !!getAllTextNodesInSelection(container, range, []).length;
    }

    function isNodeInSelection(node, range) {
      return range.intersectsNode(node);
    }

    function htmlSanitizer(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;

      const result = htmlWalker(tempDiv.childNodes);

      if (!result.blockElementCount) {
        result.html = `<p>${result.html}</p>`;
      }
      return result;
      // // second run of htmlWalker:
      // // this is needed to replace <br> with </p><p>
      // // because we only know if the root element will be a p after the first run
      // const tempDiv2 = document.createElement('div');
      // tempDiv2.innerHTML = result.html;
      // const result2 = htmlWalker(tempDiv2.childNodes);
      // return result2;
    }


    // todo, have an insideList parameter, so that P elements are not created
    function htmlWalker(children, blockElementCount = 0, insideList = false, parentTagName = null) {
      let resultHtml = '';
      if (!children?.length) {
        return { html: '', blockElementCount };
      }

      for (let i = 0; i < children.length; i++) {
        const firstNode = i == 0;
        const lastNode = i == children.length - 1;
        const node = children[i];
        if (node.nodeType === Node.ELEMENT_NODE) {
          const blockElement = elementWhitelistBlockElements.includes(node.tagName);
          const inlineElement = elementWhitelistInlineElements.includes(node.tagName);

          const isList = node.tagName === "UL" || node.tagName === "OL";

          // trim first and last node if empty
          if (firstNode && !node.innerHTML) {
            continue;
          }
          if (lastNode && !node.innerHTML) {
            continue;
          }

          if (elementsCannotBeEmptyText.includes(node.tagName) && !node.textContent.trim()) {
            continue;
          }
          if (blockElement) {
            blockElementCount++;
          }
          let tag = node.tagName.toLowerCase();
          tag = tagReplacer(tag);
          const isCode = tag === 'code';
          const isPre = tag === 'pre';
          if (isPre) {
          }
          if (isPre || isCode) {
            const codeElement = node.querySelector('code');
            const childNodes = codeElement ? codeElement.childNodes : node.childNodes;
            // 1. Get the cleaned HTML string (spans removed, other tags kept)
            const rawHtml = codeWalker(childNodes);
            // 2. Escape it so it displays literally
            const safeString = escapeHtml(rawHtml);
            // If it is the actual container, keep the tag
            console.log("parentTagName", parentTagName, new Error("HERE").stack)
            if (isPre) {
              resultHtml += `<pre><code>${safeString}</code></pre>`;
            } else {
              resultHtml += `<code>${safeString}</code>`;
            }
            blockElementCount++;
          } else if (blockElement || inlineElement) {
            const result = htmlWalker(node.childNodes, 0, isList || insideList, tag);
            blockElementCount += result.blockElementCount;
            let attributes = '';
            // TODO extend this and organize it better
            if (tag === "a") {
              attributes = ` href="${node.href}" target="_blank"`;
            }
            // TODO test: image for later
            if (tag === "img") {
              attributes = ` src="${node.src}" alt="${node.alt || ''}"`;
            }
            if (tag === "p" && insideList) {
              // if we are inside a list, we dont want to create a paragraph
              resultHtml += result.html;
            } else {
              resultHtml += `<${tag}${attributes}>${result.html || '<br>'}</${tag}>`;
            }
          } else if (node.childNodes.length) {
            // TODO if linebreak <br> we have to handle that somewhere here
            const result = htmlWalker(node.childNodes, 0, isList || insideList, tag);
            blockElementCount += result.blockElementCount;
            resultHtml += result.html;
          } else if (tag === "br") {
            if (parentTagName === "p") {
              resultHtml += '</p><p>';
            } else {
              resultHtml += '<br>';
            }
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
          resultHtml += node.nodeValue;
        }
      }

      return { html: resultHtml, blockElementCount };
    }

    /**
   * Walks through DOM nodes, stripping <span> tags but preserving their content,
   * while keeping all other elements (br, div, etc.) and text intact.
   */
    function codeWalker(children) {
      let resultHtml = '';

      if (!children?.length) {
        return resultHtml;
      }

      for (let i = 0; i < children.length; i++) {
        const node = children[i];

        if (node.nodeType === Node.ELEMENT_NODE) {
          const tag = node.tagName.toLowerCase();

          // CASE 1: SPAN
          // We want to remove the span tag but keep its content.
          // We recursively walk its children and add them to the result.
          if (tag === 'span') {
            resultHtml += codeWalker(node.childNodes);
          }
          // CASE 2: All other elements (br, div, b, etc.)
          // We want to keep these intact, including attributes.
          else {
            let attributes = '';
            if (node.hasAttributes()) {
              for (const attr of node.attributes) {
                attributes += ` ${attr.name}="${attr.value}"`;
              }
            }

            // Handle self-closing tags (void elements) like <br> or <hr>
            const voidElements = ['br', 'hr', 'img', 'input'];
            if (voidElements.includes(tag)) {
              resultHtml += `<${tag}${attributes}>`;
            } else {
              // Standard elements: Opening Tag + Children + Closing Tag
              resultHtml += `<${tag}${attributes}>${codeWalker(node.childNodes)}</${tag}>`;
            }
          }
        }
        // CASE 3: Text Nodes
        else if (node.nodeType === Node.TEXT_NODE) {
          resultHtml += node.nodeValue;
        }
      }

      return resultHtml;
    }

    function getAllTextNodesInSelection(selectionContainer, range, collectedTextNodes) {
      selectionContainer.childNodes.forEach((node) => {
        if (node.nodeType === textNodeType && range.intersectsNode(node)) {
          collectedTextNodes.push(node);
        } else {
          getAllTextNodesInSelection(node, range, collectedTextNodes);
        }
      });
      return collectedTextNodes;
    }

    // in this function return the last textNode type element
    function getLastTextNodeOfElement(element) {
      const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT)
      let lastNode = null;
      while (walker.nextNode()) {
        lastNode = walker.currentNode;
      }
      return lastNode;
    }

    function getAllBlockElementsInSelection(selectionContainer, range, collectedBlockNodes) {
      if (elementWhitelistBlockElementsInSelection.includes(selectionContainer?.tagName) && isNodeInSelection(selectionContainer, range)) {
        collectedBlockNodes.push(selectionContainer);
      }

      selectionContainer.childNodes.forEach((node) => {
        if (elementWhitelistBlockElementsInSelection.includes(node.tagName) && isNodeInSelection(node, range) && !collectedBlockNodes.includes(node)) {
          collectedBlockNodes.push(node);
        } else if (node.nodeType != textNodeType) {
          const newNodes = getAllBlockElementsInSelection(node, range, collectedBlockNodes);
        }
      });

      // if we are on an empty paragraph that only has a <br> we dont get it as an inline node
      // so we are adding it manually if this is the commonAncestorContainer
      if (!collectedBlockNodes.length && ["P", "LI"].includes(range.commonAncestorContainer.tagName) && isEmptyBlockElement(range.commonAncestorContainer)) {
        collectedBlockNodes.push(range.commonAncestorContainer);
      }
      return collectedBlockNodes;
    }

    function isEmptyBlockElement(element) {
      // Check each child node recursively
      for (let i = 0; i < element.childNodes.length; i++) {
        const node = element.childNodes[i];

        // Skip BR elements
        if (node.tagName === "BR") {
          continue;
        }

        // If it's a text node with content, element is not empty
        if (node.nodeType === textNodeType && node.textContent.trim()) {
          return false;
        }

        // For inline elements, check their contents recursively
        if (elementWhitelistInlineElements.includes(node.tagName)) {
          if (!isEmptyBlockElement(node)) {
            return false;
          }
          continue;
        }

        // For any other element type that has content
        if (node.textContent.trim()) {
          return false;
        }
      }
      return true;
    }

    function flattenInlineElements(container, tagName) {
      let inlineElements = container.querySelectorAll(tagName);
      inlineElements.forEach((elem) => {
        if (elem.parentNode.tagName.toLowerCase() == tagName) {
          replaceInlineWithTextNode(elem);
        }
      });

      // TOOD : use replaceInlineWithTextNode
      const elements = getInlineElementsToMerge(container, tagName);
      elements.forEach((elem) => {
        mergeToInlineElements(elem);
      });
    }

    function getInlineElementsToMerge(container, tagName) {
      let inlineElements = container.querySelectorAll(tagName);
      let elementsToMerge = [];
      inlineElements.forEach((elem) => {
        if (elem.nextSibling?.tagName?.toLowerCase() == tagName
          && elem.previousSibling?.tagName?.toLowerCase() !== tagName) {
          elementsToMerge.push(elem);
        }
      });
      return elementsToMerge;
    }

    function mergeToInlineElements(elem1) {
      const elem2 = elem1.nextSibling?.tagName?.toLowerCase() == elem1.tagName.toLowerCase()
        ? elem1.nextSibling
        : null;

      if (!elem2) {
        return;
      }

      while (elem2.firstChild) {
        elem1.append(elem2.firstChild);
      };

      nextElement = elem2.nextSibling?.tagName?.toLowerCase() == elem1.tagName.toLowerCase()
        ? elem2.nextSibling
        : null;
      elem2.remove();
      elem1.normalize();
      if (nextElement) {
        mergeToInlineElements(elem1, nextElement);
      }
    }

    // replaces bold/italic/etc with simple textNode
    function replaceInlineWithTextNode(element) {
      const newNode = document.createTextNode(element.textContent);
      const parentNode = element.parentNode;
      parentNode.replaceChild(newNode, element);
      parentNode.normalize();
    }

    // BEHAVIOURS >>>>>>>>>>>>>>>>>>

    dialogSaveButton.addEventListener("click", function () {
      loadFromText($("#content-text").value, editor);
      helper.saveDebounce();
      toggleDialog();
    });

    const hamburgerButton = $("#hamburger");
    hamburgerButton.addEventListener("click", function () {
      toggleDialog();
      convertTextAndDisplay();
    });
    dialogCloseButton.addEventListener("click", function () {
      toggleDialog();
    });

    boldButton.addEventListener("click", function (e) {
      makeBold(e);
    });
    italicButton.addEventListener("click", function (e) {
      makeItalic(e);
    });
    // NEW: List button event listeners
    ulButton.addEventListener("click", function (e) {
      e.preventDefault();
      wrapSelectionWithList("ul");
      helper.saveDebounce();
    });
    olButton.addEventListener("click", function (e) {
      e.preventDefault();
      wrapSelectionWithList("ol");
      helper.saveDebounce();
    });

    // const bookButton = $("#book-button");
    // bookButton.addEventListener("click", function () {
    //   page.classList.toggle("book");
    //   bookButton.classList.toggle("active");
    // });

    const editButton = $("#edit-button");
    editButton.addEventListener("click", function () {
      editor.contentEditable = editor.contentEditable === "true" ? "false" : "true";
      editButton.classList.toggle("active");
    });

    const clearButton = $("#clear-button");
    clearButton.addEventListener("click", function () {
      loadDefaultData(editor);
    });

    const observer = new MutationObserver((mutationList) => {
      mutationList
        .filter((m) => m.type === "childList")
        .forEach((m) => {
          if (m.addedNodes.length) {
            // TODO probably not needed anymore and can be removed
            // helper.elementsCleanupDebounce(editor);
          }
          m.addedNodes.forEach((insertedElement) => {
            if (insertedElement.tagName === "SPAN") {
              const text = document.createTextNode(insertedElement.textContent);
              insertedElement.replaceWith(text);
            }
            if (insertedElement.tagName === "P") {
              if (isEmptyBlockElement(insertedElement)) {
                // this fixes the issue when we are creating a title with just a bold text
                // then press enter at the end, and the next line would have an empty <p> with a <strong> in it
                insertedElement.innerHTML = '<br>';
                const emptyText = document.createTextNode("");
                // we should append this to the front of the paragraph
                insertedElement.appendChild(emptyText);
                const sel = document.getSelection() || window.getSelection();
                carretToTextNodeEnd(sel, emptyText);
              }
            }
            // this is needed because if we are in a list and at the end there is a bold element
            // and we press enter, the bold element is not removed and we end up with a list item with an empty bold element
            // this causes issues at pasting and it is not desired
            if (insertedElement.tagName === "LI") {
              console.log("inserted LI", insertedElement);
              if (isEmptyBlockElement(insertedElement)) {
                insertedElement.innerHTML = "";
              }
            }
            if (insertedElement.tagName === "DIV") {
              const pContent = insertedElement.textContent
                ? document.createTextNode(insertedElement.textContent)
                : document.createElement("br");
              const paragraph = document.createElement("p");
              paragraph.append(pContent);
              insertedElement.replaceWith(paragraph);
              putCursorAtFirstElement(paragraph, 'br');
            }
          });
        });
    });
    observer.observe(editor, { childList: true, subtree: true });

    editor.addEventListener("paste", textPaste);

    editor.addEventListener("input", (event) => {
      // if (event.isComposing || event.keyCode === 229) {
      //   return;
      // }
      // // console.log("altKey", event.altKey);
      // // console.log("ctrlKey", event.ctrlKey);
      // // console.log("key", event.key);
      if (event.inputType === "deleteContentBackward") {
        console.log("Backspace");
        if (isEmpty(editor)) {
          // TODO, check why this was here. I guess we have to 'reset' the editor
          clearContainer(editor);
        }
      }
      if (event.inputType === "insertText" && event.data === "-") {
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const range = sel.getRangeAt(0);
        let container = range.startContainer;

        // Find the closest element node (p or li)
        while (container && container.nodeType !== 1) {
          container = container.parentNode;
        }
        if (!container) return;

        // Only proceed if the element is empty except for the dash
        if (
          container.textContent.replace("\u200B", "") === "-"
        ) {
          // Remove the dash
          container.textContent = "";

          // Create UL/LI
          const ul = document.createElement("ul");
          const li = document.createElement("li");
          ul.appendChild(li);

          if (container.tagName === "P") {
            // Replace <p> with <ul>
            container.parentNode.replaceChild(ul, container);
          } else if (container.tagName === "LI") {
            // Insert <ul> after previous <li> and remove current <li>
            const prevLi = container.previousElementSibling;
            container.parentNode.removeChild(container);
            if (prevLi) {
              prevLi.appendChild(ul);
            } else {
              // If no previous li, insert at the start of the list
              container.parentNode.parentNode.insertBefore(ul, container.parentNode.nextSibling);
            }
          } else {
            // Fallback: just insert at caret
            range.insertNode(ul);
          }

          // Move caret inside the new LI
          const newRange = document.createRange();
          newRange.selectNodeContents(li);
          newRange.collapse(true);
          sel.removeAllRanges();
          sel.addRange(newRange);

          return;
        }
      }

      // New command: handle \\b for bold
      // insertCompositionText is happening on mobile devices with virtual keyboards
      if (event.inputType === "insertText" || event.inputType === "insertCompositionText") {
        const inlineElementCommands = {
          '.b': {
            command: ".b",
            element: "strong",
          },
          '.i': {
            command: ".i",
            element: "em",
          }
        }
        // const command = inlineElementCommands[event.data];
        const sel = window.getSelection();
        if (!sel.rangeCount) return;
        const range = sel.getRangeAt(0);
        let container = range.startContainer;
        // Check if the previous two characters are '\.b'
        if (container.nodeType === 3) { // text node
          const text = container.textContent;
          const offset = range.startOffset;
          if (offset >= 2) {
            const lastTwoChars = text.substring(offset - 2, offset);
            const command = inlineElementCommands[lastTwoChars];

            if (command) {
              // Remove the '\\b'
              container.textContent = text.substring(0, offset - 2) + text.substring(offset);
              // Create <b> element with an empty text node
              const inlineElement = document.createElement(command.element);
              // we should add a non breaking space into the emtpyTextNode
              const emptyText = document.createTextNode("\u200B");

              inlineElement.appendChild(emptyText);
              // Insert <b> at the correct position
              const newRange = document.createRange();
              newRange.setStart(container, offset - 2);
              newRange.collapse(true);
              newRange.insertNode(inlineElement);
              // Move caret inside the new <b> (inside the text node)
              sel.removeAllRanges();
              const caretRange = document.createRange();
              caretRange.setStart(inlineElement, inlineElement.childNodes.length);
              caretRange.collapse(true);
              sel.addRange(caretRange);
            } else if (/\s\s/.test(lastTwoChars)) {
              // Check if parent is <b>
              if (container.parentNode && ['em', 'strong', 'code'].includes(container.parentNode.tagName.toLowerCase())) {
                // Remove the 2 spaces
                container.textContent = text.substring(0, offset - 2) + text.substring(offset);
                // Move caret after the <b> element
                const bElem = container.parentNode;
                sel.removeAllRanges();
                const afterBRange = document.createRange();
                // Otherwise, insert a text node after <b> and place caret there
                // we should adda &nbsp; here:
                const textNode = document.createTextNode("\u00A0");
                if (bElem.nextSibling) {
                  bElem.parentNode.insertBefore(textNode, bElem.nextSibling);
                } else {
                  bElem.parentNode.appendChild(textNode);
                }
                afterBRange.setStart(textNode, textNode.textContent.length);
                afterBRange.collapse(true);
                sel.addRange(afterBRange);
                return;
              }
            }

          }
        }
      }
      unsaved.style.display = "inline-block";
      helper.saveDebounce();
    });

    // add an event listener when text is selected inside the editor
    document.addEventListener("selectionchange", (event) => {
      let sel, range;
      sel = document.getSelection() || window.getSelection();
      if (sel.rangeCount) {
        range = sel.getRangeAt(0);
        const isSelectionInEditor = hasAnySelectedTextNodes(editor, range);
        // const newRange = range.cloneRange();
        if (isSelectionInEditor) {
          editor.lastSelection = range.cloneRange();
        }
        // console.log("isSelectionInEditor", isSelectionInEditor);
      }

    });

    function getSelectionContainerBockElement(range) {
      let element = range.startContainer;
      console.log("first selected element:", element);
      while (element.nodeType === textNodeType || !elementWhitelistBlockElementsInSelection.includes(element.tagName)) {
        element = element.parentNode;
      }
      return element;
    }

    function getAllFirstLevelTextNodes(node) {
      let firstElement = null;
      let lastElement = null;
      node.childNodes.forEach((node) => {
        if (node.nodeType === textNodeType || elementWhitelistInlineElements.includes(node.tagName)) {
          if (!firstElement) {
            firstElement = node;
          }
          lastElement = node;
        }
      });
      return { firstElement, lastElement };
    }

    document.addEventListener('click', e => {
      const clicks = e.detail;
      const range = document.getSelection().getRangeAt(0);

      if (clicks === 3) {
        const containerBlockElement = getSelectionContainerBockElement(range);
        const { firstElement, lastElement } = getAllFirstLevelTextNodes(containerBlockElement);

        const newRange = document.createRange();
        newRange.setStart(firstElement, 0);
        newRange.setEnd(lastElement, 0);
        newRange.setStartBefore(firstElement);
        newRange.setEndAfter(lastElement);
        document.getSelection().removeAllRanges();
        document.getSelection().addRange(newRange);
      }

    });

  </script>
</body>

</html>