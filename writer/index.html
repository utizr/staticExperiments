<!DOCTYPE html>
<html>
  <!-- csss framework documentation -->
  <!-- https://purecss.io/grids/ -->

  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Writer</title>

    <link rel="stylesheet" href="./css/pure-min.css" />
    <link rel="stylesheet" href="./css/grids-responsive-min.css" />
    <link rel="stylesheet" href="./css/icons/style.css" />
    <link rel="stylesheet" href="./css/page.css" />
    <link rel="stylesheet" href="./css/colors-light.css" />

    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ“‹</text></svg>" />
  </head>

  <style></style>
  <body>
    <div id="main-menu" class="pure-menu pure-menu-horizontal">
      <a class="pure-menu-heading pure-menu-link"><div class="lsf symbol">menu</div></a>
      <ul class="pure-menu-list menu-list">
        <li class="pure-menu-item">
          <a href="#" id="button-reset" class="pure-menu-link"><div class="lsf symbol">bold</div></a>
        </li>
      </ul>
    </div>

    <div id="item-context-menu" class="pure-menu pure-menu-horizontal">
      <ul class="pure-menu-list menu-list">
        <li class="pure-menu-item">
          <a href="#" id="item-button-back" class="pure-menu-link"><div class="lsf symbol">back</div></a>
        </li>
        <li class="pure-menu-item">
          <a href="#" id="item-button-copy" class="pure-menu-link"><div class="lsf symbol">copy</div></a>
        </li>
        <li class="pure-menu-item">
          <a href="#" id="item-button-delete" class="pure-menu-link"><div class="lsf symbol">delete</div></a>
        </li>
      </ul>
    </div>

    <div id="page">
      <div id="container" contenteditable="true">
        <p>First paragraph which is awesome.</p>
        <p>Second paragraph, and is even more awesome.</p>
        <p>Third paragraph, that is even more awesome.</p>
      </div>
    </div>
    <script>
      const inlineContainers = ["p"];
      const textNodeType = 3;
      const documentFragmentType = 11;

      const editor = document.getElementById("container");

      editor.addEventListener("paste", textPaste);

      const observer = new MutationObserver((mutationList) =>
        mutationList
          .filter((m) => m.type === "childList")
          .forEach((m) => {
            m.addedNodes.forEach((insertedElement) => {
              if (insertedElement.tagName === "SPAN") {
                const text = document.createTextNode(insertedElement.textContent);
                insertedElement.replaceWith(text);
              }
            });
          }),
      );
      observer.observe(editor, { childList: true, subtree: true });

      editor.addEventListener("keyup", (event) => {
        if (event.isComposing || event.keyCode === 229) {
          return;
        }
        // console.log("altKey", event.altKey);
        // console.log("ctrlKey", event.ctrlKey);
        // console.log("key", event.key);
        if (event.key === "Backspace") {
          const empty = isEmpty(editor);
          if (empty) {
            clearContainer(container);
          }
        }
      });

      function isEmpty(editor) {
        if (editor.children.length === 1) {
          const p = editor.children[0];
          if (editor.children[0].tagName !== "P") {
            return true;
          }
        }
        if (!editor.children.length) {
          return true;
        }
        return false;
      }

      function clearContainer(container) {
        container.innerHTML = `<p><br/></p>`;

        const sel = document.getSelection() || window.getSelection();
        const rangeOnLastElement = new Range();
        rangeOnLastElement.selectNode(container.children[0].children[0]);
        rangeOnLastElement.collapse(false);
        sel.removeAllRanges();
        sel.addRange(rangeOnLastElement);
        return rangeOnLastElement;
      }

      function replaceSelectedText(replacementText) {
        const lines = replacementText.split("\n").filter((line) => {
          return line.length;
        });

        let sel, range;
        sel = document.getSelection() || window.getSelection();
        if (sel.rangeCount) {
          range = sel.getRangeAt(0);

          const elements = getAllInlineInSelection(container, range, []);

          range.deleteContents();

          if (isEmpty(editor)) {
            container.innerHTML = "";

            let lastTextNode, lastText;
            for (const line of lines) {
              const p = document.createElement("p");
              const text = document.createTextNode(line);
              lastText = line;
              lastTextNode = text;
              p.appendChild(text);
              container.append(p);
            }

            let rangeOnLastElement = new Range();
            rangeOnLastElement.setStart(lastTextNode, 0);
            rangeOnLastElement.setEnd(lastTextNode, lastText.length);
            rangeOnLastElement.collapse(false);
            sel.removeAllRanges();
            sel.addRange(rangeOnLastElement);
          } else if (elements.length == 1 && lines.length == 1) {
            // if we are inserting to the middle of the paragraph
            // and we are inserting a simple 1 line text
            const text = document.createTextNode(lines[0]);
            range.insertNode(text);
            elements[0].normalize();
            range.collapse(false);
          } else if (elements.length == 1 && lines.length > 1) {
            // if we are inserting to the middle of a paragraph
            // and we are inserting more lines.
            // In this case we are creating a new paragraph from the extracted first part
            // of the paragraph, and attach the first line; we then insert the middle lines
            // as new paragraphs. Then at the end we create a new paragraph from the extracted
            // last part of the paragraph, and attach the last line to it.
            const inlineNode = elements[0];
            const startRange = range.cloneRange();
            const endRange = range.cloneRange();
            const firstTextNode = document.createTextNode(lines.shift());
            const lastText = lines.pop();
            const lastTextNode = document.createTextNode(lastText);
            startRange.setStartBefore(inlineNode.firstChild);
            endRange.setEndAfter(inlineNode.firstChild);

            const startContent = startRange.extractContents();
            const firstNode = document.createElement("p");
            firstNode.append(startContent);
            firstNode.append(firstTextNode);
            inlineNode.before(firstNode);

            let insertAfterThis = firstNode;
            for (const line of lines) {
              const p = document.createElement("p");
              const text = document.createTextNode(line);
              p.appendChild(text);
              insertAfterThis.after(p);
              insertAfterThis = p;
            }

            const endContent = endRange.extractContents();
            const endNode = document.createElement("p");
            endNode.append(lastTextNode);
            endNode.append(endContent);
            inlineNode.after(endNode);
            range.collapse(false);

            let rangeOnLastElement = new Range();
            rangeOnLastElement.setStart(lastTextNode, 0);
            rangeOnLastElement.setEnd(lastTextNode, lastText.length);
            rangeOnLastElement.collapse(false);
            sel.removeAllRanges();
            sel.addRange(rangeOnLastElement);
          } else if (elements.length > 1) {
            // multiple lines and multiple inline elements selected
            // here we are attaching the first line to the first inline elemen
            // paste the middle ones right after
            // and attach the last line to the begining of the last inline element

            const firstTextNode = document.createTextNode(lines.shift());
            const lastText = lines.pop();
            const lastTextNode = document.createTextNode(lastText);

            const firstInline = elements[0];
            const lastInline = elements[elements.length - 1];

            firstInline.append(firstTextNode);
            firstInline.normalize();

            let insertAfterThis = firstInline;
            for (const line of lines) {
              const p = document.createElement("p");
              const text = document.createTextNode(line);
              p.appendChild(text);
              insertAfterThis.after(p);
              insertAfterThis = p;
            }
            range.collapse(false);

            if (lastText) {
              lastInline.prepend(lastTextNode);
              lastInline.normalize();
              let rangeOnLastElement = new Range();
              rangeOnLastElement.setStart(lastTextNode, 0);
              rangeOnLastElement.setEnd(lastTextNode, lastText.length);
              rangeOnLastElement.collapse(false);
              sel.removeAllRanges();
              sel.addRange(rangeOnLastElement);
            }
          }
        }
      }

      function textPaste(e) {
        console.log("event:paste");
        e.preventDefault();
        var text = e.clipboardData.getData("text/plain").trim();
        replaceSelectedText(text);
      }

      function hasAnySelectedTextNodes(container, range) {
        return !!getAllTextNodesInSelection(container, range, []).length;
      }

      function getAllTextNodesInSelection(selectionContainer, range, collectedTextNodes) {
        selectionContainer.childNodes.forEach((node) => {
          if (node.nodeType === textNodeType && range.intersectsNode(node)) {
            collectedTextNodes.push(node);
          } else {
            const newNodes = getAllTextNodesInSelection(node, range, collectedTextNodes);
          }
        });
        return collectedTextNodes;
      }

      function getAllInlineInSelection(selectionContainer, range, collectedInlineNodes) {
        if (inlineContainers.includes(selectionContainer?.tagName.toLowerCase()) && hasAnySelectedTextNodes(selectionContainer, range)) {
          collectedInlineNodes.push(selectionContainer);
        }
        selectionContainer.childNodes.forEach((node) => {
          if (inlineContainers.includes(node.tagName?.toLowerCase()) && hasAnySelectedTextNodes(node, range)) {
            collectedInlineNodes.push(node);
          } else if (node.nodeType != 3) {
            const newNodes = getAllInlineInSelection(node, range, collectedInlineNodes);
          }
        });
        // if we are on an empty paragraph that only has a <br> we dont get it as an inline node
        // so we are adding it manually if this is the commonAncestorContainer
        if (!collectedInlineNodes.length && range.commonAncestorContainer.tagName === "P") {
          collectedInlineNodes.push(range.commonAncestorContainer);
        }
        return collectedInlineNodes;
      }

      function flattenInlineElements(container, elementType) {
        let inlineElements = container.querySelectorAll(elementType);
        inlineElements.forEach((elem) => {
          if (elem.parentNode.tagName.toLowerCase() == elementType) {
            replaceInlineWithTextNode(elem);
          }
        });
      }

      // replaces bold with simple textNode
      function replaceInlineWithTextNode(element, fullRange) {
        if (fullRange) {
          const range = fullRange.cloneRange();
          if (range.startContainer.parentNode == element) {
            console.log("Starter node");
            // range.setStartBefore(inlineNode.firstChild)
          }
          if (range.endContainer.parentNode == element) {
            console.log("Ender node");
            // range.setEndAfter(inlineNode.lastChild)
          }
        }

        const newNode = document.createTextNode(element.textContent);
        const parentNode = element.parentNode;
        parentNode.replaceChild(newNode, element);
        parentNode.normalize();
      }
    </script>
  </body>
</html>
